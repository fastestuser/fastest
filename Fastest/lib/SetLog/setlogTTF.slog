%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Predicates for using {log} for the Test Template Framework (TTF)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%           by Gianfranco Rossi and Maximiliano Cristia'
%                          August 2012 
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


:- consult_lib.
:- abolish.

% is_rel(R): true if R is a (binary) relation, i.e. a set
% of ordered pairs [X,Y]

 is_rel(R) :- 
    forall(P in R, pair(P)).


% in_dom(X,Rel): true if Rel is a relation and X belongs to
% its domain

 in_dom(X,Rel) :- 
    set(Rel) &
    [X,_] in Rel.

 nin_dom(X,R) :-
   forall(P in R, exists([X1],fst(P,X1) & X neq X1)).


% is_pfun(F): true if F is a partial function, i.e. a set 
% of ordered pairs such that for each two elements [X1,Y1] and
% [X2,Y2], X1=X2 ==> Y1=Y2

 is_pfun(S) :-
     prolog_call((nonvar(S),dom_all_known(S),!,R = scan ; R = gen)) &
     (R == scan & prolog_call(is_pfun(S))
      or
      R == gen & is_pfun2(S)
     ). 

 is_pfun2(F) :- 
    forall(P1 in F, forall(P2 in F, nofork(P1,P2))).

 nofork([X1,Y1],[X2,Y2]) :-  
    (X1 neq X2 or (X1 = X2 & Y1 = Y2)).


% apply(F,X,Y): true if Y is the result of applying F to X

 apply(F,X,Y) :-
    [X,Y] in F.


% dom(Rel,Dom): true if Rel is a relation and Dom is its domain (either a set
% or an interval)

 %dom0(Rel,Dom) :-   % TO BE REMOVED
 %    set(Rel) &
 %    Dom = {X : exists(Y,[X,Y] in Rel)}.

 dom(Rel,Dom) :-
     prolog_call((nonvar(Dom),Dom = int(A,B),!, R = int ; R = set)) &
     (R == int & dom3(Rel,Dom) 
      or
      R == set & dom2(Rel,Dom)
     ). 

 % dom2(?Rel,?Dom), where Dom is either a variable or a set
 dom2({},{}).
 dom2({[X,Y]/Rel},Dom) :-
     Dom = {X/D} &
     X nin D &
     dom2(Rel,D).    

 %dom2({},{}).
 %dom2(Rel,Dom) :-   % Alternative definition: avoids repetitions caused by 
 %                   % element permutations in set unification
 %    (Rel = {[X,Y]/R} & [X,Y] nin R)! & 
 %    (Dom = {X/D} & X nin D )! &
 %    dom2(R,D).    

 % dom3(?Rel,+Dom), where Dom is an interval
 dom3({[A,Y]},Dom) :-
     Dom = int(A,A).  
 dom3({[A,Y]/Rel},Dom) :-
     Dom = int(A,B) &
     A < B &
     A1 is A + 1 & 
     D = int(A1,B) &
     dom3(Rel,D).


% dom_list(L,Dom): true if L is a list of n elements (n >= 0)
% and Dom is the interval 1..n or the empty set.  %% DA SISTEMARE!

 dom_list0([],Dom) :- Dom = {}.  % TO BE REMOVED
 dom_list0([X|L],Dom) :-
    prolog_call(length([X|L],SList)) &
    Dom = int(1,SList).

 dom_list(L,Dom) :-
     prolog_call((nonvar(Dom),!,R = int ; R = set)) &
     (R == int & dom_list3(L,Dom)
      or
      R == set & dom_list2(L,Dom)
     ). 

 % dom_list2(?L,-Dom) 
 dom_list2([],Dom) :-  
     Dom = {}.
 dom_list2([X|L],Dom) :-
     length([X|L],SList) &
     call(Dom = int(1,SList)).

 % dom_list3(?L,+Dom)         
 dom_list3(L,Dom) :-          
 %    functor(Dom,int,2) &     
     Dom = int(1,B) &
     1 =< B & 
     labeling(B) &
     length(L,B)!.
 %dom_list3(L,Dom) :-         % this case is useful if Dom can be also a set (?)
 %    (functor(Dom,with,2) or functor(Dom,{},0)) &
 %    size(Dom,B) &
 %    length(L,B)!.


% ran(Rel,Ran): true if Rel is a relation and Ran is its range (either a set
% or an interval)

 ran(Rel,Ran) :-
     prolog_call((nonvar(Ran), Ran = int(A,B), !, R = int ; R = set)) &
     (R == int & ran3(Rel,Ran) 
      or
      R == set & ran2(Rel,Ran)
     ). 

 % ran2(?Rel,?Ran), where Ran is either a variable or a set
 ran2({},{}).
 ran2({[X,Y]/Rel},Ran) :-
     Ran = {Y/R} &
     Y nin R &
     ran2(Rel,R).    

 % ran3(?Rel,+Ran), where Ran is an interval
 ran3({[A,Y]},Ran) :-
     Ran = int(A,A).  
 ran3({[A,Y]/Rel},Ran) :-
     Ran = int(A,B) &
     A < B &
     A1 is A + 1 & 
     R = int(A1,B) &
     ran3(Rel,R).


%%%% Auxiliary predicates

 pair([X,Y]).

 fst([X,Y],X).

 snd([X,Y],Y).


%%%% Using delay

 dis_rel(R) :- 
    delay(is_rel(R), nonvar(R)).

 dis_pfun(F) :- 
    delay(is_pfun(F), nonvar(F)).

 ddom(Rel,Dom) :-
    delay(dom(Rel,Dom), nonvar(Rel) & nonvar(Dom)).

 ddom_list(L,Dom) :- 
    delay(dom_list(L,Dom), nonvar(L) & nonvar(Dom)).

%%%% New definitions

bun({},{}).
bun({A/Set},S) :-  bun(Set,T) & un(A,T,S).

bdinters({A},A).
bdinters({A/Set},S) :-  bdinters(Set,T) & dinters(A,T,S).

comp({},R,{}).
comp(Q,{},{}).
comp({[X,Y]/Qel},R,S) :- %Recursion on Q
  ([Y,Z] in R &
   comp0(X,Y,R,S)) or
  ([Y,Z] nin R & 
   comp(Qel,R,S)).

comp0(X,Y,{},{}).
comp0(X1,Y1,{[X2,Y2]/Rel},S) :- %Recursion on R
  (Y1 = X2 &
   S = {[X1,Y2]/S1} &
   comp0(X1,Y1,Rel,S1)) or
  (Y1 neq X2 &
   comp0(X1,Y1,Rel,S)).

circ(Q,R,S) :- comp(R,Q,S).

dres(A,{},{}).
dres(A,{[X,Y]/Rel},S) :-
  (X in A & S = {[X,Y]/Q} & [X,Y] nin Q & dres(A,Rel,Q)) or
  (X nin A & dres(A,Rel,S)).

rres(A,{},{}).
rres(A,{[X,Y]/Rel},S) :-
  (Y in A & S = {[X,Y]/Q} & [X,Y] nin Q & rres(A,Rel,Q)) or
  (Y nin A & rres(A,Rel,S)).

ndres(A,{},{}).
ndres(A,{[X,Y]/Rel},S) :-
  (X nin A & S = {[X,Y]/R} & [X,Y] nin R & ndres(A,Rel,R)) or
  (X in A & ndres(A,Rel,S)).

nrres(A,{},{}).
nrres(A,{[X,Y]/Rel},S) :-
  (Y nin A & S = {[X,Y]/R} & [X,Y] nin R & nrres(A,Rel,R)) or
  (Y in A & nrres(A,Rel,S)).

inv({},{}).
inv({[X,Y]/Rel},R) :- R = {[Y,X]/Q} & inv(Rel,Q) & [Y,X] nin Q.

rimg({},A,{}).
rimg({[X,Y]/Rel},A,Img) :- 
  (X in A & Img = {Y/B} & Y nin B  & rimg(Rel,A,B)) or
  (X nin A & rimg(Rel,A,Img)).

oplus(R,G,S) :- dom(G,D) & ndres(D,R,S1) & un(S1,G,S).

list_to_rel([],{}).
list_to_rel([X|List],Rel) :- 
  Rel = {[1,X]/R} & 
  [1,X] nin R & 
  list_to_rel0(List,R,2).

list_to_rel0([],{},N).
list_to_rel0([X|List],Rel,N) :-
  Rel = {[N,X]/R} &
  [N,X] nin R &
  K is N + 1 &
  list_to_rel0(List,R,K).

set_to_list({},[]).
set_to_list({X/Set},List) :- List = [X|L] & set_to_list(Set,L).

extract({},List,[]).
extract(Set,[],[]).
extract(Set,List,NewList) :- 
  set_to_list(Set,L) & 
  prolog_call(sort(L,SL)) & 
  extract0(SL,List,NewList).

extract0([],List,[]).
extract0([N | IndexList], List, NewList) :-
  nth1(N,List,E) &
  NewList = [E | L] &
  extract0(IndexList,List,L).

filter(List,{},[]).
filter([],Set,[]).
filter([X|List],Set,NewList) :-
  (X in Set &
   NewList = [X | L] &
   filter(List,Set,L)) or
  (X nin Set & filter(List,Set,NewList)).

squash({},[]).
squash(Rel,List) :- 
  dom(Rel,D) & 
  set_to_list(D,LD) & 
  prolog_call(sort(LD,SLD)) & 
  squash0(Rel,SLD,List).

squash0(Rel,[],[]).
squash0(Rel,[N|List],NewList) :-
  [N,X] in Rel &
  NewList = [X|L] &
  squash0(Rel,List,L).

%%%% Prolog code

 setlogTTF_prolog :-
    prolog_call(assert((user:is_pfun({}) :- !))) &
    prolog_call(assert((user:is_pfun(S) :- S = (PFun with P), is_pfun_cont(PFun,P), is_pfun(PFun)))) &

    prolog_call(assert((user:is_pfun_cont({},_P1) :- !))) &
    prolog_call(assert((user:is_pfun_cont(S,P1) :- S = (F1 with P2), nofork(P1,P2), is_pfun_cont(F1,P1)))) &

    prolog_call(assert((user:nofork([X1,_Y1],[X2,_Y2]) :- X1 \== X2,!))) &
    prolog_call(assert((user:nofork([X1,Y1],[X2,Y2]) :- X1 = X2, Y1 = Y2))) &

    prolog_call(assert((user:dom_all_known({}) :- !))) &
    prolog_call(assert((user:dom_all_known(S) :- S = (PFun with [X,_]), nonvar(X), dom_all_known(PFun)))).

:- setlogTTF_prolog.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%setloglib.slog
%%% version 4.6.12-3

% corretto un bug nella int_to_bag
% int_to_bag(int(A,A),*{A}) invece di
% int_to_bag(int(A,A),{A}).

%% aggiunta definizione di ein, enin, esubset, essubset - da completare
%% usato esubset, essubset nelle dsubset, dssubset


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%  The {log} standard library  %%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%   version 4.6    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%                  March 2008 - by Gianfranco Rossi
%             Extended August 2012 - by Gianfranco Rossi
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% This file contains the {log} definition of a number of predicates,
% mostly dealing with sets and bags, which are not (yet) provided as 
% primitive in {log}. 
% It can be  loaded into the {log} environment by issuing the 
% goal consult_lib (provided 'setloglib.slog' is the name you 
% give to this file).
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% General operations dealing with sets
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

powerset(S,PS) :-               % powerset(+S,?PS) is true if PS is the powerset 
     PS = {SS : subset(SS,S)}.  % of S (i.e., PS = 2^S)

cross_product(A,B,CP) :-        % cross_product(+A,+B,?CP) is true if CP is the 
     CP = {X : exists([Y,Z],    % Cartesian product of sets A and B
           X = {Y,Z} & Y in A & Z in B)}.

list_to_set([],{}).             % list_to_set(+L,?S) is true if S denotes the set
list_to_set([X|L],{X\S}) :-     % of all elements of the list L
     list_to_set(L,S).

int_to_set(int(A,A),{A}).       % int_to_set(+I,?S) is true if S denotes the set
int_to_set(int(A,B),{A\S}) :-   % of all elements of the interval I  
     A < B &
     A1 is A + 1 &
     int_to_set(int(A1,B),S).

diff1({X\S},X,S) :-             % diff1(?S,?X,?R) equivalent to diff(S,{X},R)
     X nin S.                   % but more efficient
diff1(S,X,S) :- 
     X nin S.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Improved implementations of primitive set constraints:
% �reduce the number of repeated equivalent solutions  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

xless(S,X,SS) :-               % remove the element X from S, if S is ground
     test(ground(S),R) &       % otherwise, remove any element X from S
    (R=true  & less(S,X,SS)! or
     R=false & less(S,X,SS)). 

xun(R,S,U) :-                  % union  (T = R \cup S)
     test(ground(R),H) &
    (H=true  & xxun(R,S,U) or
     H=false & un(R,S,U)). 
xxun('{}',X,X).                % T = R \cup S, with R ground    
xxun(R,S,{X\U}) :-
    less(R,X,RR)! &
    X nin S &
    xxun(RR,S,U).
xxun(R,S,U) :-
    less(R,X,RR)! &
    call(X in S) &
    xun(RR,S,U).

xdiff(R,S,U) :-                % difference (T = R \setminus S)
     test(ground(R),H) &
    (H=true  & xxdiff(R,S,U) or
     H=false & diff(R,S,U)). 
xxdiff({},_,{}).               % T = R \setminus S, with R ground  
xxdiff(R,S,T) :- 
    less(R,X,RR)! & 
    call(X in S) &
    xxdiff(RR,S,T).
xxdiff(R,S,{X\U}) :-
    less(R,X,RR)! &
    X nin S &
    xxdiff(RR,S,U).

xndiff(R,S,T) :-               % not difference (T = R \not\setminus S)
    xdiff(R,S,T1) & 
    T1 neq T.

xsdiff(R,S,T) :-               % symmetric difference (T = R \triangle S) 
    xdiff(R,S,A) &
    xdiff(S,R,B) & 
    xun(A,B,T). 

xsize(S,N) :-                  % cardinality (N = |S|)
    size(S,N).                 % for compatibility with previous releases

xsubset(S1,S2) :-              % subset (S1 \subseteq S2)
    subset(S1,S2).             % for compatibility with previous releases

xinters(R,S,U) :-              % intersection  (T = R \cap S)
     inters(R,S,U).            % for compatibility with previous releases
                  
test(Pred,Res) :-
   prolog_call((call(Pred),!,Res=true ; Res=false)).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Improved {log} set constraints, allowing intervals with
%%%% unspecified bounds
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% improved subset/2

 isubset(S1,S2) :-   
    prolog_call((nonvar(S1), S1=int(A1,B1), nonvar(S2), S2=int(A2,B2),!, R=intint ; R=gen)) &
    (R==intint & intint_subset(S1,S2)
     or
     R==gen & subset(S1,S2)
    ). 

 intint_subset(S1,S2) :-
    S1=int(A1,B1) &
    S2=int(A2,B2) &
    A1=<B1 & A2=<B2 &
    A1>=A2 & B1=<B2.

% improved ssubset/2 ("strict subset")
 issubset(S1,S2) :-
    prolog_call((nonvar(S1), S1=int(A1,B1), nonvar(S2), S2=int(A2,B2),!, R=intint ; R=gen)) &
    (R==intint & intint_ssubset(S1,S2)
     or
     R==gen & ssubset(S1,S2)
    ).
 intint_ssubset(S1,S2) :-
    S1=int(A1,B1) &
    S2=int(A2,B2) &
    A1=<B1 & A2=<B2 &
    (A1>A2 & B1=<B2 or A1>=A2 & B1<B2).

% improved nsubset/2 ("not subset")
 insubset(S1,S2) :-
    prolog_call((nonvar(S1), S1=int(A1,B1), nonvar(S2), S2=int(A2,B2),!, R=intint ; R=gen)) &
    (R==intint & intint_nsubset(S1,S2)
     or
     R==gen & nsubset(S1,S2)
    ).
 intint_nsubset(S1,S2) :-
    S1=int(A1,B1) &
    S2=int(A2,B2) &
    A1=<B1 & A2=<B2 &
    (A1<A2 or B2<B1).

% improved inters/3
 iinters(S1,S2,S3) :-   
    prolog_call((nonvar(S1), S1=int(A1,B1), nonvar(S2), S2=int(A2,B2),!, R=intint ; R=gen)) &
    (R==intint & intint_inters(S1,S2,S3)
     or
     R==gen & inters(S1,S2,S3)
    ). 
 intint_inters(S1,S2,S3) :-
    S1=int(A1,B1) &
    S2=int(A2,B2) &
    max(A1,A2,A3) &
    min(B1,B2,B3) &
    (A3>B3 & S3={} 
     or
     A3=<B3 & S3=int(A3,B3)
    ).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Delayed set operations 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

 dint_to_set(A,B,S) :-
    delay(int_to_set(int(A,B),S),nonvar(A) & nonvar(B)).

 dsubset(S1,S2) :-     
%    delay(isubset(S1,S2), nonvar(S1)).
     esubset(S1,S2).

 dnsubset(S1,S2) :-     
%     delay(insubset(S1,S2), nonvar(S1)).
     ensubset(S1,S2).

 dssubset(S1,S2) :-     
%    delay(issubset(S1,S2), nonvar(S1)).
     essubset(S1,S2).

 dinters(S1,S2,S3) :-  
%    delay(iinters(S1,S2,S3), nonvar(S1) & nonvar(S2)).  
     einters(S1,S2,S3).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Dealing with multisets 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

bag_to_set({},{}).              % bag_to_set(+M,?S) is true if S denotes the set
bag_to_set(M,{X\S}) :-          % of all elements of the multiset M
     (M = *{X\R})! &
     bag_to_set(R,S).

int_to_bag(int(A,A),*{A}).       % int_to_bag(+I,?M) is true if M denotes the multiset
int_to_bag(int(A,B),*{A\M}) :-  % of all elements of the interval I   
     A < B &
     A1 is A + 1 &
     int_to_bag(int(A1,B),M).

msize(S,N) :- in_msize(S,0,N).  % msize(?S,?N) is true if N is the cardinality 
in_msize({},N,N).               % of the multiset S (i.e., N = |S|)
in_msize(*{_\SS},N,M) :-
    N neq M &
    NN is N + 1 &
    in_msize(SS,NN,M).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Dealing with lists 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%prefix(P,L) true if list P is a prefix of list L
 prefix(P,L) :-
    append(P,_,L).

%sublist(Sb,L) true if list Sb is a sublist of list L
 sublist(Sb,L) :- 
    prefix(Sb,L).
 sublist(Sb,[H|T]) :- 
    Sb neq [] &
    sublist(Sb,T).

%take(N,L,NewL) true if list NewL consists of the
%first N elements of list L
 take(0,L,[ ]).
 take(N,[H|T],[H|R]) :- 
    N>0 & M is N-1 &
    take(M,T,R).

%drop(N,L,NewL) true if list NewL is L with its 
%first N elements removed
 drop(0,L,L).
 drop(N,[H|T],R) :- 
    N >0 & M is N-1 &
    drop(M,T,R).


% Redefining Prolog built-ins (for the user convenience)
 
 member(X,L) :- prolog_call(member(X,L)).

 append(L1,L2,L3) :- prolog_call(append(L1,L2,L3)).

 nth1(X,L,Y) :- prolog_call(nth1(X,L,Y)).

 length(L,N) :- prolog_call(length(L,N)).

 reverse(L,R) :- prolog_call(reverse(L,R)).

 last(L,X) :- prolog_call(last(L,X)).

    
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Interactive help predicates
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


setlog_lib_help :-
   nl & 
   write('The {log} library provides a number of predicates ') & nl & 
   write('dealing with sets and bags which are not provided ') & nl &
   write('as primitive in {log}.') & nl & nl &
   write('It can be loaded into the {log} environment by issuing the ') & nl & 
   write('goal consult_lib (provided ''setloglib.slog'' is the name you ') & nl &
   write('give to the library file).') & nl.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Improved {log} set constraints, allowing intervals with
%%%% unspecified bounds - EXTENDED VERSIONS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

:- prolog_call(op(700,xfx,[ein,enin])).

 T ein S :-
     prolog_call(
         (unbounded_int(S),!,R = case1 
          ; 
          R = case2
         )
     ) &
     ein(R,T,S).

 ein(case1,T,int(A,B)) :-      % S is an unbounded interval
     T >= A & T =< B.
 ein(case2,T,S) :-
     T in S.
   
  
 T enin S :-
     prolog_call(
         (unbounded_int(S),!,R = case1 
          ; 
          R = case2
         )
     ) &
     enin(R,T,S).

 enin(case1,T,int(A,B)) :-     % S is an unbounded interval
     T < A or T > B.
 enin(case2,T,S) :-
     T in S.


 esubset(S1,S2) :-
     prolog_call(
         (nonvar(S1), nonvar(S2), 
          S1=int(A1,B1), S2=int(A2,B2), \+ground([A1,B1,A2,B2]),!,R = case1 
          ; 
          unbounded_int(S1),!,R = case2
          ;
          unbounded_int(S2),!,R = case3
          ;
          R = case4
         )
     ) &
    esubset(R,S1,S2).

 esubset(case1,int(A1,B1),_) :-           % subset(empty_interval,int)
     int(A1,B1) = {}.
 esubset(case1,int(A1,B1),int(A2,B2)) :-  % subset(int,int)
     int(A1,B1) neq {} & int(A2,B2) neq {} &
     A1 >= A2 & B1 =< B2.
 esubset(int(A,B),S) :-                   % subset(empty_interval,set)
     set(S) & A > B.
 esubset(case2,int(A,A),S) :-             % subset(singleton_interval,set)
     set(S) & A in S. 
 esubset(case2,int(A,B),S) :-             % subset(int,set)
     set(S) & A < B & 
     A in S &
     A1 is A + 1 &
     esubset(int(A1,B),S).          
 esubset(case3,{},_).                     % subset({},int)
 esubset(case3,S,int(A,B)) :-             % subset(set,int)
     set(S) & S neq {} &
     smin(S,N) & smax(S,M) &
     N >= A & M =< B.
 esubset(case4,S1,S2) :-                  % subset(_AnyOther,_AnyOther)
     subset(S1,S2).
 
 
% essubset(S1,S2)    TO BE COMPLETED!!

 essubset(S1,S2) :-
     prolog_call(
         (nonvar(S1), nonvar(S2), 
          S1=int(A1,B1),S2=int(A2,B2),\+ground([A1,B1,A2,B2]),!,R = case1 
          ; 
%          unbounded_int(S1),!,R = case2
%          ;
%          unbounded_int(S2),!,R = case3
%          ;
          R = case4
         )
     ) &
     essubset(R,S1,S2).

  essubset(case1,int(A1,B1),int(A2,B2)) :-  % ssubset(empty_int,non-empty_int)
     int(A1,B1) = {} &
     A2 =< B2.
  essubset(case1,int(A1,B1),int(A2,B2)) :-  % ssubset(non-empty_int,non-empty_int)
     int(A1,B1) neq {} & int(A2,B2) neq {} &
     (A1 > A2 & B1 =< B2 or A1 >= A2 & B1 < B2).
  essubset(case4,S1,S2) :-                  % nsubset(_AnyOther,_AnyOther)
     ssubset(S1,S2).

% ensubset(S1,S2)    TO BE COMPLETED!!

 ensubset(S1,S2) :-
     prolog_call(
         (nonvar(S1), nonvar(S2), 
          S1=int(A1,B1),S2=int(A2,B2),\+ground([A1,B1,A2,B2]),!,R = case1 
          ; 
%          unbounded_int(S1),!,R = case2
%          ;
%          unbounded_int(S2),!,R = case3
%          ;
          R = case4
         )
     ) &
     ensubset(R,S1,S2).

 ensubset(case1,int(A1,B1),int(A2,B2)) :-  % nsubset(int,int)
     int(A1,B1) neq {} & int(A2,B2) neq {} &
     (A1<A2 or B2<B1).
 ensubset(case4,S1,S2) :-                  % nsubset(_AnyOther,_AnyOther)
     nsubset(S1,S2).


% einters(S1,S2,S3)  TO BE COMPLETED!!

 einters(S1,S2,S3) :-
     prolog_call(
         (nonvar(S1), nonvar(S2),
          S1=int(A1,B1),S2=int(A2,B2),\+ground([A1,B1,A2,B2]),!,R = case1 
          ; 
%          unbounded_int(S1),!,R = case2
%          ;
%          unbounded_int(S2),!,R = case3
%          ;
          R = case4
         )
     ) &
     einters(R,S1,S2,S3).

 einters(case1,int(A1,B1),int(A2,B2),{}) :-  
    int(A1,B1) = {}.
 einters(case1,int(A1,B1),int(A2,B2),{}) :-  
    int(A2,B2) = {}.
 einters(case1,int(A1,B1),int(A2,B2),S3) :-  
    int(A1,B1) neq {} & int(A2,B2) neq {} &
    max(A1,A2,A3) &
    min(B1,B2,B3) &
    (A3>B3 & S3={} 
     or
     A3=<B3 & S3=int(A3,B3)
    ).
 einters(case4,S1,S2,S3) :-                 % inters(_AnyOther,_AnyOther,S3)
    inters(S1,S2,S3).

 max(A,B,A) :-
    A >= B.
 max(A,B,B) :-
    A < B.

 min(A,B,A) :-
    A =< B.
 min(A,B,B) :-
    A > B.

 
%%%%%%%%%%%%%%% Auxiliary predicates - Prolog code

 setlog_prolog :-
    prolog_call(assert((user:unbounded_int(I) :- nonvar(I), I=int(A,B), (var(A),! ; var(B)) ))).

:- setlog_prolog.
