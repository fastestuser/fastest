/* Generated By:JavaCC: Do not edit this line. TCRL_Parser.java */
//********************************************************************************
//							        PAQUETE
//********************************************************************************
// Este es el PAQUETE en FASTEST al cual pertenecer�n las CLASES generadas
// por javaCC para el REFINAMIENTO a JAVAS
package client.blogic.testing.refinementOld.java;
//********************************************************************************
//						         IMPORTACIONES
//********************************************************************************
import java.util.*;
// import java.io.*;

//********************************************************************************
//					      DECLARACIONES de las CLASES
//********************************************************************************


//********************************************************************************
//                CLASES que reprentan al MODULO LOGICO AST
//********************************************************************************

//********************************************************************************
/**
 * CLASE que representa la ra�z del �RBOL de SINTAXIS ABSTRACTA. Contiene
 * el NOMBRE de la LEY de REFINAMIENTO, el texto del PR�AMBULO, el texto del EP�LOGO
 * y las REGLAS de REFINAMIENTO contenidas en la LEY de REFINAMIENTO.
 *
 * @author  Diego Hollman
 * @author  Pablo D. Coca
 *
 * @since   v1.0
 *
 * @version 2.0
 */
class TCRL_AST {

    private String      name;
    // private String specLang:
    // private String implLang:
    private String      preamble;
        private NodeRules   rules;
    private String      epilogue;


   /**
    * CONSTRUCTOR de la clase TCRL_AST
    * 
    * @param		lawName		NOMBRE de la LEY de REFINAMIENTO
    * @param		preamble	PREAMBULO de la LEY de REFINAMIENTO
    * @param		rules		REGLAS de REFINAMIENTO contenidas en la LEY de REFINAMIENTO
    * @param		epilogue	EPILOGO de la LEY de REFINAMIENTO
    */
    TCRL_AST(String lawName, String preamble, NodeRules rules, String epilogue) {

        this.name        = lawName;
        this.preamble    = preamble;
        this.rules       = rules;
        this.epilogue    = epilogue;

    }

   /**
    * Devuelve el NOMBRE de la LEY de REFINAMIENTO
    * 
    * @return	el NOMBRE de la LEY de REFINAMIENTO
    */
    public String getName(){
        return name;
    }

   /**
    * Devuelve el PREAMBULO de la LEY de REFINAMIENTO
    * 
    * @return	el PREAMBULO de la LEY de REFINAMIENTO
    */
    public String getPreamble(){
        return preamble;
    }

   /**
    * Devuelve el NOMBRE de la LEY de REFINAMIENTO
    * 
    * @return	el EP�LOGO de la LEY de REFINAMIENTO
    */
    public String getEpilogue(){
        return epilogue;
    }

   /**
    * Devuelve las REGLAS de REFINAMIENTO contenidas en la LEY de REFINAMIENTO
    * 
    * @return	las REGLAS de REFINAMIENTO contenidas en la LEY de REFINAMIENTO
    */
    public NodeRules getRules(){
        return rules;
    }
}
//********************************************************************************
/**
 * Este nodo del ARBOL de SINTAXIS ABSTRACTA contiene el conjunto
 * de todas las REGLAS de REFINAMIENTO, cada una como una instancia de la clase NodeRule.
 *
 * @see NodeRule
 *
 * @author  Diego Hollman
 * @author  Pablo D. Coca
 *
 * @since   v1.0
 *
 * @version 2.0
 */
class NodeRules {

        // Quiero hacer este SIN�NIMO de TIPO:
        // RuleName = String

    // el 1er. ARGUMENTO del HashMap es el NOMBRE de la REGLA
    private HashMap<String, NodeRule> rules = new HashMap<String, NodeRule>();

        // Sirve para generar los NOMBRES a REGLAS que fueron agregadas
        // sin NOMBRE.
        // NOTA: El NOMBRE de la REGLA (RuleName) es OPCIONAL en TCRL
        private Integer COUNTER = 0;

   /**
    * Agrega una REGLA de REFINAMIENTO
    * 
    * @param	ruleName    NOMBRE de la REGLA de REFINAMIENTO [OPCIONAL]
    * @param	rule   		REGLA de REFINAMIENTO asociada al NOMBRE de la
    *                  		REGLA de REFINAMIENTO
    *
    * @see NodeRule
    */
        public void addRule(String ruleName, NodeRule rule){
                rules.put(ruleName,rule);
        }

   /**
    * Agrega una REGLA de REFINAMIENTO
    *
    * @param	rule   		REGLA de REFINAMIENTO.
    *						Se asociada a un NOMBRE de
    *                  		REGLA de REFINAMIENTO generado autom�ticamente
    *						de la forma: RULE_NAME_GENERATED_#number,
    *						donde number es un N�MERO generado autom�ticamente
    *						por la IMPLEMENTACI�N de la CLASE NodeRules.
    *
    * @see NodeRule
    */
        public void addRule(NodeRule rule){

                String RULE_NAME_GENERATED  = new String("RULE_NAME_GENERATED_#" + COUNTER.toString());

                COUNTER = COUNTER + 1;

                addRule(RULE_NAME_GENERATED, rule);
        }

   /**
    * Obtiene la REGLA de REFINAMIENTO con NOMBRE ruleName
    * 
    * @param    ruleName    NOMBRE de la REGLA de REFINAMIENTO
    *
    * @return   la REGLA de REFINAMIENTO asociada
    */
    public NodeRule getRule(String ruleName){
        return rules.get(ruleName);
    }

   /**
    * Obtiene una LISTA de los NOMBRES de todas las REGLAS de REFINAMIENTO
    *
    * @return   la LISTA de los NOMBRES de todas las REGLAS de REFINAMIENTO
    */
    public Set<String> getKeys(){
        return rules.keySet();
    }
}
//********************************************************************************
/**
 * Representa la INTERFAZ para todos los NODOS para TIPOS en el �RBOL de SINTAXIS ABSTRACTA
 * Los NODOS para TIPOS particulares son por ej: NodeArrray, NodeList, etc.
 * HEREDAN de esta CLASE.
 *
 * @author  Diego Hollman
 * @author  Pablo D. Coca
 *
 * @since   v1.0
 *
 * @version 2.0
 */
class NodeType {

// Asi vacio esta el MODULO en la pagina 30

}
//********************************************************************************
/**
 * Representa a una REGLA (ya sea de SIN�NIMO o de REFINAMIENTO)
 * para una VARIABLE de la ESPECIFICACI�N FORMAL en Z.
 *
 * @author  Diego Hollman
 * @author  Pablo D. Coca
 *
 * @since   v1.0
 *
 * @version 2.0
 */
class NodeRule {

//    protected NodeType nodeType;
//
//   /**
//    * Devuelve el TIPO del NODO
//    *
//    * @return   el TIPO del NODO
//    *
//    * @see NodeType
//    */
//    public NodeType getNodeType(){
//        return nodeType;
//    }

}
//********************************************************************************
/**
 * Representa el TIPO de NODO en el ARBOL de SINTAXIS ABSTRACTA
 * que almacena una REGLA de SINONIMO.
 * Extiende a la CLASE NodeRule.
 *
 * @see NodeRule
 *
 * @author  Diego Hollman
 * @author  Pablo D. Coca
 *
 * @since   v1.0
 *
 * @version 2.0
 */
class RuleSynonym extends NodeRule {

    private String name;
        private NodeType nodeType;

   /**
    * CONSTRUCTOR de la CLASE
    * 
    * @param    synonymName		NOMBRE de la REGLA de SINONIMO
    * @param    nodeType		NODO que CONTIENE la REGLA de SINONIMO
    *
    * @see NodeType
    */
    RuleSynonym(String synonymName, NodeType nodeType) {

        this.name = synonymName;
        this.nodeType = nodeType;     // type esta declarada en NodeRule

    }

   /**
    * Devuelve el NOMBRE que se le asigno a la REGLA de SIN�NIMO
    *
    * @return   el NOMBRE que se le asigno a la REGLA de SIN�NIMO
    */
    public String getName(){
        return name;
    }

   /**
    * Devuelve el TIPO de NODO asociado a la REGLA de SIN�NIMO
    *
    * @return   el TIPO de NODO asociado a la REGLA de SIN�NIMO
    */
        public NodeType getNodeType(){
        return nodeType;
    }
}
//********************************************************************************
/**
 * Representa el TIPO de NODO en el ARBOL de SINTAXIS ABSTRACTA
 * que almacena una REGLA de REFINAMIENTO.
 * Extiende a la CLASE NodeRule.
 *
 * @see NodeRule
 *
 * @author  Diego Hollman
 * @author  Pablo D. Coca
 *
 * @since   v1.0
 *
 * @version 2.0
 */
class RuleRefinement extends NodeRule {

    private ArrayList<String> specIDs;  // Ej: specIDs = {"day", "month","year"}

        // date:STRUCTURE[ .... ]
    private HashMap<String, NodeType> implIDs;

    // ImplVARS: VARIABLES de la IMPLEMENTACION asociadas a codigo JAVA
    // para el REFINAMIENTO
    private HashMap<ArrayList<String>, String> implVARS;


    // SpecVARS: VARIABLES de la ESPECIFICACION asociadas a codigo JAVA
    // para el proceso de ABSTRACCION (todavia no DESARROLLADO)
        //private HashMap< ArrayList<String>, String> specVARS;

        // VARIABLES de la ESPECIFICACION asociadas a codigo JAVA
        private Abstraction abstraction;


   /**
    * CONSTRUCTOR
    * 
    * @param    specificationNames   	NOMBRES de la VARIABLES en la ESPECIFICACION
    * @param    implementationNames     NOMBRE y TIPO de NODO de la VARIABLES en la IMPLEMENTACION
    * @param    implVARS            	
    * @param    specVARS            	
    *
    * @see NodeType
    */
    RuleRefinement      (       ArrayList<String> specificationIDs,
                                        HashMap<String, NodeType> implementationIDs,
                                        HashMap< ArrayList<String>, String> implVARS,   // quiz�s deba llamarse REF
                                        Abstraction abstraction
                                )
    {
        this.specIDs            = specificationIDs;
        this.implIDs            = implementationIDs;
        this.abstraction        = abstraction;
        this.implVARS           = implVARS;
    }

   /**
    * Devuelve los NOMBRES de la VARIABLES de la ESPECIFICACI�N asociadas
    * a la REGLA de REFINAMIENTO
    *
    * @return   los NOMBRES de la VARIABLES de la ESPECIFICACI�N asociadas
    *           a la REGLA de REFINAMIENTO
    */
    public ArrayList<String> getSpecIDs(){
        return specIDs;
    }

   /**
    * Devuelve los NOMBRES de las VARIABLES en la IMPLEMENTACI�N asociadas
    * a la REGLA de REFINAMIENTO
    *
    * @return   los NOMBRES de las VARIABLES en la IMPLEMENTACI�N asociadas
    *           a la REGLA de REFINAMIENTO
    */
    public Set<String> getImplIDs(){
        return implIDs.keySet();
    }

    public NodeType getNodeType(String implID){
        return implIDs.get(implID);
    }

        public void setNodeType(String implID, NodeType nodeType){
        implIDs.put(implID, nodeType);
    }

    public Abstraction getAbstraction()
    {
        return abstraction;
    }

    public HashMap< ArrayList<String>, String> getImplVARS(){
        return implVARS;
    }
}
//********************************************************************************


//********************************************************************************
/**
 * Represents the SECTION "ASBTRACTION" of one REFINEMENT RULE
 *
 * @author  Pablo D. Coca
 *
 * @since   v2.0
 *
 * @version 2.0
 */
class Abstraction
{
        //			   (specID, equality) 
    private HashMap<String, List <Equality > > equalities;

   /**
    * CONSTRUCTOR
    * 
    * @param    equalities   	Equalities        	
    *
    */

    Abstraction()
    {
        // this.equalities		= null;
        this.equalities         = new HashMap<String, List<Equality > >();
    }

    Abstraction (HashMap<String, List<Equality> > equalities)
    {
        this.equalities         = equalities;
    }

        public void addEquality(String specID, Equality equality)
        {
        if ( ! equalities.containsKey( specID ) )
        {
            List        listEqualities  =       new ArrayList( );

            listEqualities.add(equality);

            equalities.put( specID, listEqualities);
        }
        else
        {
            List        listEqualities = (List) equalities.get(specID);

            listEqualities.add( equality );

                        equalities.remove(specID);

            equalities.put( specID, listEqualities);
        }


        // equalities.put(	specID, equality);
    }

    public HashMap<String, List<Equality> > getEqualities()
        {
        return  equalities;
    }

        public List<Equality> getEqualities(String specID)
        {
        return  equalities.get(specID);
    }

}
//********************************************************************************


//********************************************************************************
/**
 * Represents an EQUALITY of an "ABSTRACTION"
 *
 * @author  Pablo D. Coca
 *
 * @since   v2.0
 * @version 2.0
 */
class Equality
{
        private String  preOperatorSpecID;
        private String  postOperatorSpecID;

        private String  plCodePreamble;
    private     String  plCodeEquality;

        //--------------------------------------------------------------------------------
        /**
    * CONSTRUCTOR
    */
    Equality    ()
    {
        this.preOperatorSpecID          = null;
        this.postOperatorSpecID         = null;
        this.plCodePreamble                     = null;
        this.plCodeEquality                     = null;
    }
        //--------------------------------------------------------------------------------
        /**
    * CONSTRUCTOR
    */
    Equality    (       String  preOperatorSpecID,
                                String  postOperatorSpecID,
                                        String  plCodePreamble,
                                        String  plCodeEquality
                        )
    {
        this.preOperatorSpecID          = preOperatorSpecID;
        this.postOperatorSpecID         = postOperatorSpecID;
        this.plCodePreamble                     = plCodePreamble;
        this.plCodeEquality                     = plCodeEquality;
    }
        //--------------------------------------------------------------------------------
        public void setPreOperatorSpecID(String preOperatorSpecID)
        {
        this.preOperatorSpecID          =       preOperatorSpecID;
    }

        public String getPreOperatorSpecID()
        {
        return preOperatorSpecID;
    }
        //--------------------------------------------------------------------------------
        public void setPostOperatorSpecID(String postOperatorSpecID)
        {
        this.postOperatorSpecID         =       postOperatorSpecID;
    }

        public String getPostOperatorSpecID()
        {
        return postOperatorSpecID;
    }
        //--------------------------------------------------------------------------------
        public void setPLCodePreamble(String plCodePreamble)
        {
        this.plCodePreamble             =       plCodePreamble;
    }

        public String getPLCodePreamble()
        {
        return plCodePreamble;
    }
        //--------------------------------------------------------------------------------
        public void setPLCodeEquality(String plCodeEquality)
        {
        this.plCodeEquality             =       plCodeEquality;
    }

        public String getPLCodeEquality()
        {
        return plCodeEquality;
    }
        //--------------------------------------------------------------------------------

}
//********************************************************************************





//********************************************************************************
//              CLASES que reprentan al MODULO LOGICO NodeType
//********************************************************************************

//********************************************************************************
class NodeSynonym extends NodeType {

    private String id;

    NodeSynonym(String synonymID) {
        id = synonymID;
    }

    public String getID(){
        return id;
    }
}
//********************************************************************************
class NodePointer extends NodeType{

    private NodeType type;

    NodePointer(NodeType type){
        this.type = type;
    }

    public NodeType getType(){
        return type;
    }
}
//********************************************************************************
/**
 * Representa el TIPO de NODO en el ARBOL de SINTAXIS ABSTRACTA
 * que almacena TIPOS PRIMITVOS del LENGUAJE de IMPLEMENTACI�N (ej: int, char, boolean).
 *
 *
 * @author  Pablo D. Coca
 *
 * @since   v2.0
 *
 * @version 2.0
 */
class NodePLType extends NodeType {

    private String type;

    NodePLType(String type)
    {
        this.type = type;
    }

    public String getType()
    {
        return type;
    }
}
//********************************************************************************
class NodeArray extends NodeType {

    private     NodeType        type;
    private     int                     size;

    NodeArray(NodeType nodeType, int size)
    {
        this.type = nodeType;
        this.size = size;
    }

    public NodeType getType()
    {
        return type;
    }

    public int getSize()
    {
        return size;
    }
}
//********************************************************************************
/**
 * Represents the NODE for the ELEMENTS of NodeStructure
 *
 * @author  Pablo D. Coca
 *
 * @since   v2.0
 *
 * @version 2.0
 */
class NodeElement extends NodeType{

    private String              id;
    private NodeType    type;
        private String          constant;

    NodeElement(String id, NodeType     type){
       this.id = id;
       this.type = type;
       this.constant = null;
    }

    NodeElement(String id, NodeType     type, String constant){
       this.id = id;
       this.type = type;
       this.constant = constant;
    }

    public String getID(){
        return id;
    }

    public NodeType getType(){
        return type;
    }

    public String getConstant(){
        return constant;
    }

}
//********************************************************************************
/**
 * Represents the TYPE in the ABSTRAX SYNTAX TREE
 * which saves a JAVA CLASS.
 *
 *
 * @author  Pablo D. Coca
 *
 * @since   v2.0
 *
 * @version 2.0
 */
class NodeStructure extends NodeType{

    private String name;        // Si es necesario el TESTER debe ingresar el NOMBRE
                                                // de la CLASE precedi�ndola con el PAQUETE que la CONTIENE.
                                                // EJEMPLO: java.lang.Integer 

    private List<NodeElement> elements;

        // CONSTRUCTOR
    NodeStructure(      String name,
                                List<NodeElement> elements      // VER si hay que SACAR o CAMBIAR
                         )
        {
        this.name       = name;
        this.elements   = elements;
    }

    public String getName(){
        return name;
    }

        public List<NodeElement> getElements(){
        return elements;
    }

}
//********************************************************************************
/**
/**
 * Represents the NODE TYPE in the ABSTRAX SYNTAX TREE
 * which saves ENUMERATED TYPES.
 *
 * @author  Pablo D. Coca
 *
 * @since   v2.0
 *
 * @version 2.0
 */
class NodeEnumeration extends NodeType{

    private NodeType                                            type;
        // <element, constant >
        private HashMap<String, String> elements = new HashMap<String, String>();

        // CONSTRUCTOR
    NodeEnumeration     (       NodeType type,
                                        HashMap<String, String> elements
                                )
        {
        this.type       = type;
        this.elements   = elements;
    }

    public NodeType getType()
    {
        return type;
    }

        public HashMap<String, String> getElements()
        {
        return elements;
    }

        public String getConstant(String element)
        {
        return elements.get(element);
    }
}
//********************************************************************************
class NodeList extends NodeType{

    private String name;
    private String linkType;
    private String linkNextName;
    private String linkPrevName;
    private String memAlloc;
    List<NodeElement> fields;

    NodeList(String n, String lt, String ln, String lp, List<NodeElement> f, String m)
    {
        name = n;
        linkType = lt;
        linkNextName = ln;
        linkPrevName = lp;
        fields = f;
        memAlloc = m;
    }

    public String getName(){
        return name;
    }

    public String getLinkType(){
        return linkType;
    }

    public String getLinkNextName(){
        return linkNextName;
    }

    public String getLinkPrevName(){
        return linkPrevName;
    }

    public List<NodeElement> getFields(){
        return fields;
    }

    public String getMemAlloc(){
        return memAlloc;
    }
}
//********************************************************************************
class NodeFile extends NodeType{

    private String name;
    private String path;
    private String delimiter;
    private String eof;
    private String eol;
    private String structure;

    public String getName(){
        return name;
    }

    public String getPath(){
        return path;
    }

    public String getDelimiter(){
        return delimiter;
    }

    public String getEol(){
        return eol;
    }

    public String getEof(){
        return eof;
    }

    public String getStructure(){
        return structure;
    }

        //Y el token fieldsRelation?
    NodeFile(String name, String path, String delimiter, String eol, String eof, String structure){
        this.name = name;
        this.path = path;
        this.delimiter = delimiter;
        this.eol = eol;
        this.eof = eof;
        this.structure = structure;
    }
}
//********************************************************************************
class NodeDBColumn extends NodeType{

    private String colName;
    private String colType;

    public String getColName(){
        return colName;
    }

    public String getColType(){
        return colType;
    }

    NodeDBColumn(String n, String t){
        colName = n;
        colType = t;
    }
}
//********************************************************************************
class NodeDB extends NodeType{

        private String dbmsID;
    private String connectionID;
    private String tableName;
        private List<NodeDBColumn> columns;

        public String getDBMSID(){
        return dbmsID;
    }

    public String getConnectionID(){
                return connectionID;
        }

    public String getTableName(){
                return tableName;
        }

        public List<NodeDBColumn> getColumns(){
                return columns;
        }

        NodeDB(String dbmsID, String connectionID, String tableName, List<NodeDBColumn> columns){
                this.dbmsID                     =       dbmsID;
        this.connectionID       =       connectionID;
        this.tableName          =       tableName;
                this.columns            =       columns;
        }
}
//********************************************************************************
class NodeRFR extends NodeType{

    private String lawName, specID;

    public String getLawName(){
        return lawName;
    }

    public String getSpecID(){
        return specID;
    }

    NodeRFR(String lawName, String specID){
        this.lawName    =       lawName;
        this.specID             =       specID;
    }
}
//********************************************************************************
public class TCRL_Parser implements TCRL_ParserConstants {

        public static void main(String args[]) throws ParseException {

                // RENOMBRADA ya que no se ACCESA
                TCRL_AST r;

            TCRL_Parser parser = new TCRL_Parser(System.in);

            r   =       TCRL_Parser.parse();
  }

//********************************************************************************



//********************************************************************************
//										BNF
//********************************************************************************

//********************************************************************************
  static final public TCRL_AST parse() throws ParseException {
  String                lawName;
  String                preamble;
  NodeRules             rules;
  String                epilogue;
    lawName = LawName();
    preamble = Preamble();
    rules = Rules();
    epilogue = Epilogue();
    jj_consume_token(0);
    {if (true) return new TCRL_AST(        lawName,
                                                preamble,
                                                rules,
                                                epilogue
                                        );}
    throw new Error("Missing return statement in function");
  }

//********************************************************************************
  static final public String LawName() throws ParseException {
  Token name;
    name = jj_consume_token(ID);
    jj_consume_token(EOL);
     {if (true) return name.image;}
    throw new Error("Missing return statement in function");
  }

 //********************************************************************************
  static final public String Preamble() throws ParseException {
  Token plCode;
    jj_consume_token(PREAMBLE);
    plCode = jj_consume_token(PLCODE);
     {if (true) return plCode.image;}
    throw new Error("Missing return statement in function");
  }

//********************************************************************************
  static final public String Epilogue() throws ParseException {
  Token plCode;
    jj_consume_token(EPILOGUE);
    plCode = jj_consume_token(PLCODE);
     {if (true) return plCode.image;}
    throw new Error("Missing return statement in function");
  }

//********************************************************************************
  static final public NodeRules Rules() throws ParseException {
    NodeRule    rule;
    NodeRules   rules = new NodeRules();
    Token               ruleName = new Token();
    jj_consume_token(RULES);
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EOL:
        ;
        break;
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
      jj_consume_token(EOL);
    }
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ID:
        ;
        break;
      default:
        jj_la1[1] = jj_gen;
        break label_2;
      }
                ruleName = new Token(); // RESET the TOKEN

      if (jj_2_1(2)) {
        ruleName = jj_consume_token(ID);
        jj_consume_token(COLON);
      } else {
        ;
      }
      rule = Rule();
      label_3:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case EOL:
          ;
          break;
        default:
          jj_la1[2] = jj_gen;
          break label_3;
        }
        jj_consume_token(EOL);
      }
                        if (ruleName.image != null)
                        rules.addRule(ruleName.image, rule);
                else
                        rules.addRule(rule);
    }
        {if (true) return rules;}
    throw new Error("Missing return statement in function");
  }

//********************************************************************************
  static final public NodeRule Rule() throws ParseException {
  NodeRule nodeRule;
    if (jj_2_2(3)) {
      nodeRule = RuleSynonym();
              {if (true) return nodeRule;}
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ID:
        nodeRule = RuleRefinement();
               {if (true) return nodeRule;}
        break;
      default:
        jj_la1[3] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

//********************************************************************************
  static final public RuleSynonym RuleSynonym() throws ParseException {
    Token id;
    NodeType nodeType;
    id = jj_consume_token(ID);
    jj_consume_token(DEQUAL);
    nodeType = Type();
                {if (true) return new RuleSynonym( id.image,
                                                                nodeType
                                                           );}
    throw new Error("Missing return statement in function");
  }

//********************************************************************************
  static final public RuleRefinement RuleRefinement() throws ParseException {
        ArrayList<String>                       specIDs;
        HashMap<String, NodeType>       implIDs         = new HashMap<String, NodeType>();

        Abstraction                                     abstraction     = new Abstraction();

    Token implID;
    NodeType nodeType;
    specIDs = SpecIDS();
    jj_consume_token(ARROW);
    implID = jj_consume_token(ID);
    jj_consume_token(COLON);
    nodeType = Type();
                                                                  implIDs.put(implID.image, nodeType);
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[4] = jj_gen;
        break label_4;
      }
      jj_consume_token(COMMA);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EOL:
        jj_consume_token(EOL);
        break;
      default:
        jj_la1[5] = jj_gen;
        ;
      }
      // for VISUAL ASPECTS
      
                                                                implID = jj_consume_token(ID);
      jj_consume_token(COLON);
      nodeType = Type();
                                                            implIDs.put(implID.image, nodeType);
    }
    if (jj_2_3(2)) {
      jj_consume_token(EOL);
      abstraction = Abstraction();
    } else {
      ;
    }
                {if (true) return new RuleRefinement(      specIDs,
                                                                        implIDs,
                                                                        null,           // AGREGAR REFINAMIENTO
                                                                        abstraction
                                                                  );}
    throw new Error("Missing return statement in function");
  }

//********************************************************************************
  static final public ArrayList<String> SpecIDS() throws ParseException {
   Token specID;
   ArrayList<String> specIDs = new ArrayList<String>();
    specID = jj_consume_token(ID);
          specIDs.add(specID.image);
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[6] = jj_gen;
        break label_5;
      }
      jj_consume_token(COMMA);
      label_6:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case EOL:
          ;
          break;
        default:
          jj_la1[7] = jj_gen;
          break label_6;
        }
        jj_consume_token(EOL);
      }
      specID = jj_consume_token(ID);
                  specIDs.add(specID.image);
    }
                  {if (true) return specIDs;}
    throw new Error("Missing return statement in function");
  }

//********************************************************************************
  static final public Abstraction Abstraction() throws ParseException {
        Token           preOperatorSpecID       = new Token();
        Token           specID;
        Token           plCodePreamble          = new Token();
        Token           plCodeEquality;
        Equality        equality;
        Abstraction     abstraction                     = new Abstraction();
    jj_consume_token(ABSTRACTION);
    label_7:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CODE:
      case SET:
        ;
        break;
      default:
        jj_la1[8] = jj_gen;
        break label_7;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CODE:
        jj_consume_token(CODE);
        // The WORD @PLCODE
        
                                plCodePreamble = jj_consume_token(PLCODE_ABSTRACTION);
        break;
      default:
        jj_la1[9] = jj_gen;
        ;
      }
      jj_consume_token(SET);
      if (jj_2_4(2)) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case dom:
          preOperatorSpecID = jj_consume_token(dom);
          break;
        case ran:
          preOperatorSpecID = jj_consume_token(ran);
          break;
        case cardinal:
          preOperatorSpecID = jj_consume_token(cardinal);
          break;
        case partition:
          preOperatorSpecID = jj_consume_token(partition);
          break;
        default:
          jj_la1[10] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      } else {
        ;
      }
      specID = jj_consume_token(ID_ABSTRACTION);
      jj_consume_token(AS);
      plCodeEquality = jj_consume_token(PLCODE_ABSTRACTION);
                        equality        = new Equality  (
                                                                                        preOperatorSpecID.image,
                                                                                        null,                                   //postOperator
                                                                                        plCodePreamble.image,
                                                                                        plCodeEquality.image
                                                                                );

                        abstraction.addEquality (
                                                                        specID.image,
                                                                        equality
                                                                        );
    }
    jj_consume_token(END_ABSTRACTION);
                {if (true) return abstraction;}
    throw new Error("Missing return statement in function");
  }

//********************************************************************************
  static final public NodeType Type() throws ParseException {
    NodeType nodeType;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SYNONYM:
      nodeType = Synonym();
                        {if (true) return nodeType;}
      break;
    case PLTYPE:
      nodeType = PLType();
                        {if (true) return nodeType;}
      break;
    case ENUMERATION:
      nodeType = Enumeration();
                        {if (true) return nodeType;}
      break;
    case ARRAY:
      nodeType = Array();
                        {if (true) return nodeType;}
      break;
    case POINTER:
      nodeType = Pointer();
                    {if (true) return nodeType;}
      break;
    case STRUCTURE:
      nodeType = Structure();
                        {if (true) return nodeType;}
      break;
    case LIST:
      nodeType = List();
                        {if (true) return nodeType;}
      break;
    case FILE:
      nodeType = File();
                        {if (true) return nodeType;}
      break;
    case DB:
      nodeType = DB();
                        {if (true) return nodeType;}
      break;
    case RFR:
      nodeType = RFR();
                        {if (true) return nodeType;}
      break;
    default:
      jj_la1[11] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

//********************************************************************************
  static final public NodeSynonym Synonym() throws ParseException {
    Token id;
    jj_consume_token(SYNONYM);
    id = jj_consume_token(ID);
       {if (true) return new NodeSynonym(id.image);}
    throw new Error("Missing return statement in function");
  }

//********************************************************************************
  static final public NodePLType PLType() throws ParseException {
    Token id;
    jj_consume_token(PLTYPE);
    id = jj_consume_token(STRING);
                {if (true) return new NodePLType((id.image).substring(1, (id.image).length() -1));}
    throw new Error("Missing return statement in function");
  }

//********************************************************************************
  static final public NodeEnumeration Enumeration() throws ParseException {
    NodePLType                                  plType;
    Token                                               enumerationElement;
        Token                                           constant;
    HashMap<String, String>     elements        =       new HashMap<String, String>();
    jj_consume_token(ENUMERATION);
    label_8:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EOL:
        ;
        break;
      default:
        jj_la1[12] = jj_gen;
        break label_8;
      }
      jj_consume_token(EOL);
    }
    jj_consume_token(LBRACKET);
    label_9:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EOL:
        ;
        break;
      default:
        jj_la1[13] = jj_gen;
        break label_9;
      }
      jj_consume_token(EOL);
    }
    plType = PLType();
    label_10:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[14] = jj_gen;
        break label_10;
      }
      jj_consume_token(COMMA);
      label_11:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case EOL:
          ;
          break;
        default:
          jj_la1[15] = jj_gen;
          break label_11;
        }
        jj_consume_token(EOL);
      }
      enumerationElement = jj_consume_token(ID);
      jj_consume_token(76);
      constant = jj_consume_token(STRING);
                                    elements.put        (       enumerationElement.image,
                                                                        (constant.image).substring      (       1,
                                                                                                                                        ((constant.image).length() - 1)
                                                                                                                                )
                                                                );
    }
    label_12:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EOL:
        ;
        break;
      default:
        jj_la1[16] = jj_gen;
        break label_12;
      }
      jj_consume_token(EOL);
    }
    jj_consume_token(RBRACKET);
                {if (true) return new      NodeEnumeration(        plType,
                                                                                elements
                                                                        );}
    throw new Error("Missing return statement in function");
  }

//********************************************************************************
  static final public NodePointer Pointer() throws ParseException {
    NodeType type;
    jj_consume_token(POINTER);
    label_13:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EOL:
        ;
        break;
      default:
        jj_la1[17] = jj_gen;
        break label_13;
      }
      jj_consume_token(EOL);
    }
    jj_consume_token(LBRACKET);
    label_14:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EOL:
        ;
        break;
      default:
        jj_la1[18] = jj_gen;
        break label_14;
      }
      jj_consume_token(EOL);
    }
    type = Type();
    label_15:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EOL:
        ;
        break;
      default:
        jj_la1[19] = jj_gen;
        break label_15;
      }
      jj_consume_token(EOL);
    }
    jj_consume_token(RBRACKET);
        {if (true) return new NodePointer(type);}
    throw new Error("Missing return statement in function");
  }

//********************************************************************************
  static final public NodeArray Array() throws ParseException {
    NodeType    type;
    Token               s       =       null;
    jj_consume_token(ARRAY);
    label_16:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EOL:
        ;
        break;
      default:
        jj_la1[20] = jj_gen;
        break label_16;
      }
      jj_consume_token(EOL);
    }
    jj_consume_token(LBRACKET);
    label_17:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EOL:
        ;
        break;
      default:
        jj_la1[21] = jj_gen;
        break label_17;
      }
      jj_consume_token(EOL);
    }
    type = Type();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COMMA:
      jj_consume_token(COMMA);
      label_18:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case EOL:
          ;
          break;
        default:
          jj_la1[22] = jj_gen;
          break label_18;
        }
        jj_consume_token(EOL);
      }
      s = jj_consume_token(NUMBER);
      break;
    default:
      jj_la1[23] = jj_gen;
      ;
    }
    label_19:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EOL:
        ;
        break;
      default:
        jj_la1[24] = jj_gen;
        break label_19;
      }
      jj_consume_token(EOL);
    }
    jj_consume_token(RBRACKET);
        Integer size = new Integer(s.image);
        {if (true) return new NodeArray(type, size.intValue());}
    throw new Error("Missing return statement in function");
  }

//********************************************************************************
  static final public NodeStructure Structure() throws ParseException {
    List<NodeElement> elements = new ArrayList<NodeElement>();
    NodeElement element;
    Token id;
    jj_consume_token(STRUCTURE);
    label_20:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EOL:
        ;
        break;
      default:
        jj_la1[25] = jj_gen;
        break label_20;
      }
      jj_consume_token(EOL);
    }
    jj_consume_token(LBRACKET);
    label_21:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EOL:
        ;
        break;
      default:
        jj_la1[26] = jj_gen;
        break label_21;
      }
      jj_consume_token(EOL);
    }
    id = jj_consume_token(ID);
    label_22:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[27] = jj_gen;
        break label_22;
      }
      jj_consume_token(COMMA);
      label_23:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case EOL:
          ;
          break;
        default:
          jj_la1[28] = jj_gen;
          break label_23;
        }
        jj_consume_token(EOL);
      }
      element = Element();
                                            elements.add(element);
    }
    label_24:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EOL:
        ;
        break;
      default:
        jj_la1[29] = jj_gen;
        break label_24;
      }
      jj_consume_token(EOL);
    }
    jj_consume_token(RBRACKET);
                {if (true) return new NodeStructure(id.image, elements);}
    throw new Error("Missing return statement in function");
  }

//********************************************************************************
  static final public NodeElement Element() throws ParseException {
    Token element;
    NodeType type;
    Token constant = new Token();
    element = jj_consume_token(ID);
    jj_consume_token(COLON);
    type = Type();
    if (jj_2_5(2)) {
      jj_consume_token(COMMA);
      constant = Constant();
    } else {
      ;
    }
                        if (constant.image != null)
                        {if (true) return new NodeElement(element.image, type, constant.image);}
                else
                        {if (true) return new NodeElement(element.image, type);}
    throw new Error("Missing return statement in function");
  }

//********************************************************************************
  static final public Token Constant() throws ParseException {
    Token constant;
    constant = jj_consume_token(STRING);
              {if (true) return constant;}
    throw new Error("Missing return statement in function");
  }

//********************************************************************************
  static final public NodeList List() throws ParseException {
    // List<NodeElement> fields = new ArrayList<NodeElement>();
        List<NodeElement> elements = new ArrayList<NodeElement>();
    Token id;
    // Token linkType, listNext, listPrevius = null, mem = null;
    NodeElement element;
    jj_consume_token(LIST);
    jj_consume_token(LBRACKET);
    id = jj_consume_token(ID);
    label_25:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[30] = jj_gen;
        break label_25;
      }
      jj_consume_token(COMMA);
      element = Element();
                                        elements.add(element);
    }
    jj_consume_token(RBRACKET);
        {if (true) return new NodeList(    id.image,
                                                        null,
                                                        null,
                                                        null,
                                                        elements,
                                                        null
                                                );}
    throw new Error("Missing return statement in function");
  }

//********************************************************************************
  static final public NodeFile File() throws ParseException {
    Token name, path, delimiter, eol = null, eof = null, structure = null;
    jj_consume_token(FILE);
    jj_consume_token(LBRACKET);
    name = jj_consume_token(STRING);
    jj_consume_token(COMMA);
    path = jj_consume_token(STRING);
    jj_consume_token(COMMA);
    delimiter = jj_consume_token(STRING);
    if (jj_2_6(2)) {
      jj_consume_token(COMMA);
      jj_consume_token(ENDOFLINE);
      eol = jj_consume_token(STRING);
    } else {
      ;
    }
    if (jj_2_7(2)) {
      jj_consume_token(COMMA);
      jj_consume_token(ENDOFFILE);
      eof = jj_consume_token(STRING);
    } else {
      ;
    }
    if (jj_2_8(2)) {
      jj_consume_token(COMMA);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LINEAR:
        structure = jj_consume_token(LINEAR);
        break;
      case RPL:
        structure = jj_consume_token(RPL);
        break;
      case FPL:
        structure = jj_consume_token(FPL);
        break;
      default:
        jj_la1[31] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } else {
      ;
    }
    jj_consume_token(RBRACKET);
                {if (true) return new NodeFile(    name.image,
                                                                path.image,
                                                                delimiter.image,
                                                                (eol == null)           ?
                                                                                                                        null
                                                                                                                :
                                                                                                                        eol.image,
                                                                (eof == null)           ?
                                                                                                                        null
                                                                                                                :
                                                                                                                        eof.image,
                                                                (structure == null)     ?
                                                                                                                        null
                                                                                                                :
                                                                                                                        structure.image
                                                        );}
    throw new Error("Missing return statement in function");
  }

//********************************************************************************
  static final public NodeDB DB() throws ParseException {
    Token dbmsID, connectionID, tableName, columnID;
    String columnType;
    List<NodeDBColumn> columns = new ArrayList<NodeDBColumn>();
    jj_consume_token(DB);
    jj_consume_token(LBRACKET);
    dbmsID = jj_consume_token(ID);
    jj_consume_token(COMMA);
    connectionID = jj_consume_token(ID);
    jj_consume_token(COMMA);
    tableName = jj_consume_token(ID);
    label_26:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[32] = jj_gen;
        break label_26;
      }
      jj_consume_token(COMMA);
      columnID = jj_consume_token(ID);
      jj_consume_token(COLON);
      columnType = columnType();
                        NodeDBColumn c = new NodeDBColumn(columnID.image, columnType);
                    columns.add(c);
    }
    jj_consume_token(RBRACKET);
                {if (true) return new NodeDB(      dbmsID.image,
                                                        connectionID.image,
                                                        tableName.image,
                                                        columns
                                                 );}
    throw new Error("Missing return statement in function");
  }

//********************************************************************************
  static final public String columnType() throws ParseException {
    Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INT:
      // VER SI HAY QUE MODIFICAR o AGREGAR TIPOS
                  t = jj_consume_token(INT);
                {if (true) return t.image;}
      break;
    case CHAR:
      t = jj_consume_token(CHAR);
                {if (true) return t.image;}
      break;
    case VARCHAR:
      t = jj_consume_token(VARCHAR);
                {if (true) return t.image;}
      break;
    default:
      jj_la1[33] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

//********************************************************************************
  static final public NodeRFR RFR() throws ParseException {
    Token lawName, specID;
    jj_consume_token(RFR);
    jj_consume_token(LBRACKET);
    lawName = jj_consume_token(ID);
    jj_consume_token(COMMA);
    specID = jj_consume_token(ID);
    jj_consume_token(RBRACKET);
        {if (true) return new NodeRFR(lawName.image, specID.image);}
    throw new Error("Missing return statement in function");
  }

  static private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  static private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  static private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  static private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  static private boolean jj_2_5(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_5(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(4, xla); }
  }

  static private boolean jj_2_6(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_6(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(5, xla); }
  }

  static private boolean jj_2_7(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_7(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(6, xla); }
  }

  static private boolean jj_2_8(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_8(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(7, xla); }
  }

  static private boolean jj_3R_43() {
    if (jj_scan_token(ENUMERATION)) return true;
    return false;
  }

  static private boolean jj_3R_28() {
    if (jj_scan_token(ABSTRACTION)) return true;
    return false;
  }

  static private boolean jj_3R_36() {
    if (jj_3R_46()) return true;
    return false;
  }

  static private boolean jj_3_3() {
    if (jj_scan_token(EOL)) return true;
    if (jj_3R_28()) return true;
    return false;
  }

  static private boolean jj_3R_35() {
    if (jj_3R_45()) return true;
    return false;
  }

  static private boolean jj_3R_50() {
    if (jj_scan_token(RFR)) return true;
    return false;
  }

  static private boolean jj_3_5() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_29()) return true;
    return false;
  }

  static private boolean jj_3_1() {
    if (jj_scan_token(ID)) return true;
    if (jj_scan_token(COLON)) return true;
    return false;
  }

  static private boolean jj_3R_49() {
    if (jj_scan_token(DB)) return true;
    return false;
  }

  static private boolean jj_3R_44() {
    if (jj_scan_token(ARRAY)) return true;
    return false;
  }

  static private boolean jj_3R_34() {
    if (jj_3R_44()) return true;
    return false;
  }

  static private boolean jj_3R_48() {
    if (jj_scan_token(FILE)) return true;
    return false;
  }

  static private boolean jj_3R_33() {
    if (jj_3R_43()) return true;
    return false;
  }

  static private boolean jj_3R_46() {
    if (jj_scan_token(STRUCTURE)) return true;
    return false;
  }

  static private boolean jj_3R_42() {
    if (jj_scan_token(PLTYPE)) return true;
    return false;
  }

  static private boolean jj_3R_27() {
    if (jj_scan_token(ID)) return true;
    if (jj_scan_token(DEQUAL)) return true;
    if (jj_3R_30()) return true;
    return false;
  }

  static private boolean jj_3_4() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(57)) {
    jj_scanpos = xsp;
    if (jj_scan_token(58)) {
    jj_scanpos = xsp;
    if (jj_scan_token(59)) {
    jj_scanpos = xsp;
    if (jj_scan_token(60)) return true;
    }
    }
    }
    return false;
  }

  static private boolean jj_3R_32() {
    if (jj_3R_42()) return true;
    return false;
  }

  static private boolean jj_3_2() {
    if (jj_3R_27()) return true;
    return false;
  }

  static private boolean jj_3R_30() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_31()) {
    jj_scanpos = xsp;
    if (jj_3R_32()) {
    jj_scanpos = xsp;
    if (jj_3R_33()) {
    jj_scanpos = xsp;
    if (jj_3R_34()) {
    jj_scanpos = xsp;
    if (jj_3R_35()) {
    jj_scanpos = xsp;
    if (jj_3R_36()) {
    jj_scanpos = xsp;
    if (jj_3R_37()) {
    jj_scanpos = xsp;
    if (jj_3R_38()) {
    jj_scanpos = xsp;
    if (jj_3R_39()) {
    jj_scanpos = xsp;
    if (jj_3R_40()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  static private boolean jj_3R_31() {
    if (jj_3R_41()) return true;
    return false;
  }

  static private boolean jj_3_8() {
    if (jj_scan_token(COMMA)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(26)) {
    jj_scanpos = xsp;
    if (jj_scan_token(27)) {
    jj_scanpos = xsp;
    if (jj_scan_token(28)) return true;
    }
    }
    return false;
  }

  static private boolean jj_3R_40() {
    if (jj_3R_50()) return true;
    return false;
  }

  static private boolean jj_3R_41() {
    if (jj_scan_token(SYNONYM)) return true;
    return false;
  }

  static private boolean jj_3_7() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_scan_token(ENDOFFILE)) return true;
    return false;
  }

  static private boolean jj_3R_47() {
    if (jj_scan_token(LIST)) return true;
    return false;
  }

  static private boolean jj_3_6() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_scan_token(ENDOFLINE)) return true;
    return false;
  }

  static private boolean jj_3R_39() {
    if (jj_3R_49()) return true;
    return false;
  }

  static private boolean jj_3R_29() {
    if (jj_scan_token(STRING)) return true;
    return false;
  }

  static private boolean jj_3R_38() {
    if (jj_3R_48()) return true;
    return false;
  }

  static private boolean jj_3R_45() {
    if (jj_scan_token(POINTER)) return true;
    return false;
  }

  static private boolean jj_3R_37() {
    if (jj_3R_47()) return true;
    return false;
  }

  static private boolean jj_initialized_once = false;
  /** Generated Token Manager. */
  static public TCRL_ParserTokenManager token_source;
  static SimpleCharStream jj_input_stream;
  /** Current token. */
  static public Token token;
  /** Next token. */
  static public Token jj_nt;
  static private int jj_ntk;
  static private Token jj_scanpos, jj_lastpos;
  static private int jj_la;
  static private int jj_gen;
  static final private int[] jj_la1 = new int[34];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
      jj_la1_init_2();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x230fe000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1c000000,0x0,0x0,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x2000,0x10,0x2000,0x10,0x1000,0x2000,0x1000,0x2000,0x1000000,0x1000000,0x1e000000,0x0,0x2000,0x2000,0x1000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0x1000,0x2000,0x2000,0x2000,0x1000,0x2000,0x2000,0x1000,0x0,0x1000,0x7,};
   }
   private static void jj_la1_init_2() {
      jj_la1_2 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
  static final private JJCalls[] jj_2_rtns = new JJCalls[8];
  static private boolean jj_rescan = false;
  static private int jj_gc = 0;

  /** Constructor with InputStream. */
  public TCRL_Parser(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public TCRL_Parser(java.io.InputStream stream, String encoding) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new TCRL_ParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 34; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 34; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public TCRL_Parser(java.io.Reader stream) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new TCRL_ParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 34; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  static public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 34; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public TCRL_Parser(TCRL_ParserTokenManager tm) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 34; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(TCRL_ParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 34; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  static private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  static final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  static private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  static final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  static final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  static private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  static private java.util.List jj_expentries = new java.util.ArrayList();
  static private int[] jj_expentry;
  static private int jj_kind = -1;
  static private int[] jj_lasttokens = new int[100];
  static private int jj_endpos;

  static private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      jj_entries_loop: for (java.util.Iterator it = jj_expentries.iterator(); it.hasNext();) {
        int[] oldentry = (int[])(it.next());
        if (oldentry.length == jj_expentry.length) {
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              continue jj_entries_loop;
            }
          }
          jj_expentries.add(jj_expentry);
          break jj_entries_loop;
        }
      }
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  /** Generate ParseException. */
  static public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[77];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 34; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 77; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  static final public void enable_tracing() {
  }

  /** Disable tracing. */
  static final public void disable_tracing() {
  }

  static private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 8; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
            case 4: jj_3_5(); break;
            case 5: jj_3_6(); break;
            case 6: jj_3_7(); break;
            case 7: jj_3_8(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  static private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
