


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%  The {log} standard library  %%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%   version 4.6    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%                  March 2008 - by Gianfranco Rossi
%             Extended August 2012 - by Gianfranco Rossi
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% This file contains the {log} definition of a number of predicates,
% mostly dealing with sets and bags, which are not (yet) provided as 
% primitive in {log}. 
% It can be  loaded into the {log} environment by issuing the 
% goal consult_lib (provided 'setloglib.slog' is the name you 
% give to this file).
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

powerset(S,PS) :-               % powerset(+S,?PS) is true if PS is the powerset 
     PS = {SS : subset(SS,S)}.  % of S (i.e., PS = 2^S)

cross_product(A,B,CP) :-        % cross_product(+A,+B,?CP) is true if CP is the 
     CP = {X : exists([Y,Z],    % Cartesian product of sets A and B
           X = {Y,Z} & Y in A & Z in B)}.

list_to_set([],{}).             % list_to_set(+L,?S) is true if S denotes the set
list_to_set([X|L],{X\S}) :-     % of all elements of the list L
     list_to_set(L,S).

bag_to_set({},{}).              % bag_to_set(+M,?S) is true if S denotes the set
bag_to_set(M,{X\S}) :-          % of all elements of the multiset M
     (M = *{X\R})! &
     bag_to_set(R,S).

int_to_set(int(A,A),{A}).       % int_to_set(+I,?S) is true if S denotes the set
int_to_set(int(A,B),{A\S}) :-   % of all elements of the interval I  
     A < B &
     A1 is A + 1 &
     int_to_set(int(A1,B),S).

int_to_bag(int(A,A),{A}).       % int_to_bag(+I,?M) is true if M denotes the multiset
int_to_bag(int(A,B),*{A\M}) :-  % of all elements of the interval I   
     A < B &
     A1 is A + 1 &
     int_to_bag(int(A1,B),M).

diff1({X\S},X,S) :-             % diff1(?S,?X,?R) equivalent to diff(S,{X},R)
     X nin S.                   % but more efficient
diff1(S,X,S) :- 
     X nin S.

msize(S,N) :- in_msize(S,0,N).  % msize(?S,?N) is true if N is the cardinality 
in_msize({},N,N).               % of the multiset S (i.e., N = |S|)
in_msize(*{_\SS},N,M) :-
    N neq M &
    NN is N + 1 &
    in_msize(SS,NN,M).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% The following predicates provide
% an improved implementation of the basic set-theoretic operations
% that reduces the number of repeated equivalent solutions  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

xless(S,X,SS) :-              % remove the element X from S, if S is ground
     test(ground(S),R) &      % otherwise, remove any element X from S
    (R=true  & less(S,X,SS)! or
     R=false & less(S,X,SS)). 

xun(R,S,U) :-                 % union  (T = R \cup S)
     test(ground(R),H) &
    (H=true  & xxun(R,S,U) or
     H=false & un(R,S,U)). 
xxun('{}',X,X).                   
xxun(R,S,{X\U}) :-
    less(R,X,RR)! &
    X nin S &
    xxun(RR,S,U).
xxun(R,S,U) :-
    less(R,X,RR)! &
    call(X in S) &
    xun(RR,S,U).

xdiff(R,S,U) :-                % difference (T = R \setminus S)
     test(ground(R),H) &
    (H=true  & xxdiff(R,S,U) or
     H=false & diff(R,S,U)). 
xxdiff({},_,{}).              
xxdiff(R,S,T) :- 
    less(R,X,RR)! & 
    call(X in S) &
    xxdiff(RR,S,T).
xxdiff(R,S,{X\U}) :-
    less(R,X,RR)! &
    X nin S &
    xxdiff(RR,S,U).

xndiff(R,S,T) :-               % not difference (T = R \not\setminus S)
    xdiff(R,S,T1) & 
    T1 neq T.

xsdiff(R,S,T) :-               % symmetric difference (T = R \triangle S) 
    xdiff(R,S,A) &
    xdiff(S,R,B) & 
    xun(A,B,T). 


xsize(S,N) :-                  % cardinality (N = |S|)
    size(S,N).                 % for compatibility with previous releases

xsubset(S1,S2) :-              % subset (S1 \subseteq S2)
    subset(S1,S2).             % for compatibility with previous releases


xint(R,S,U) :-                 % intersection  (T = R \cap S)
     inters(R,S,U).           % for compatibility with previous releases
                  

test(Pred,Res) :-
   prolog_call((call(Pred),!,Res=true ; Res=false)).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Interactive help predicates
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

setlog_lib_help :-
   nl &
   write('Available {log} library predicates:') &
   nl & nl &
   write('powerset(+S,?PS): powerset (PS = 2^S)') & nl &
   write('cross_product(+A,+B,?CP): the Cartesian product of sets A and B') & nl &
   write('list_to_set(+L,?S): S is the set of all elements of the list L') & nl &
   write('bag_to_set(+M,?S): S is the set of all elements of the bag M') & nl &
   write('int_to_set(+I,?S): S is the set of all elements of the interval I') & nl &
   write('int_to_bag(+I,?M): M is the multiset of all elements of the interval I') & nl &
   write('diff1(?S,?X,?R): equivalent to diff(S,{X},R) but more efficient') & nl &
   write('msize(?S,?N): multiset cardinality (N = |S|)') & nl &
   setlog_lib_help2.

setlog_lib_help2 :-
   nl & 
   write('The {log} library provides also alternative definitions for some ') & nl & 
   write('set predicates ... and much more ....') & nl.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Redefining Prolog built-ins (for the user convenience)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

 length(L,N) :-
    prolog_call(length(L,N)).

 nth1(X,L,Y) :-
    prolog_call(nth1(X,L,Y)).

 % TO BE CONTINUED ...


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Redefining {log} constraints as user-defined predicates
%%%% (allows constraints to be considered as they occur in the 
%%%% goal - not before all other literals in the goal)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

 in_int(X,A,B) :-
    X in int(A,B).

 % TO BE CONTINUED ...


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Delayed set operations 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

 dint_to_set(A,B,S) :-
    delay(int_to_set(int(A,B),S),nonvar(A) & nonvar(B)).

 dsubset(S1,S2) :-     
    delay(isubset(S1,S2), nonvar(S1)).

 dssubset(S1,S2) :-     
    delay(issubset(S1,S2), nonvar(S1)).

 dinters(S1,S2,S3) :-  
    delay(iinters(S1,S2,S3), nonvar(S1) & nonvar(S2)).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Improved {log} set constraints, allowing intervals with
%%%% unspecified bounds
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% improved subset/2
 isubset(S1,S2) :-   
    prolog_call((nonvar(S1), S1=int(A1,B1), nonvar(S2), S2=int(A2,B2),!, R=intint ; R=gen)) &
    (R==intint & intint_subset(S1,S2)
     or
     R==gen & subset(S1,S2)
    ). 

 intint_subset(S1,S2) :-
    S1=int(A1,B1) &
    S2=int(A2,B2) &
    A1=<B1 & A2=<B2 &
    A1>=A2 & B1=<B2.

% improved ssubset/2 ("strict subset")
 issubset(S1,S2) :-
    prolog_call((nonvar(S1), S1=int(A1,B1), nonvar(S2), S2=int(A2,B2),!, R=intint ; R=gen)) &
    (R==intint & intint_ssubset(S1,S2)
     or
     R==gen & ssubset(S1,S2)
    ).
 intint_ssubset(S1,S2) :-
    S1=int(A1,B1) &
    S2=int(A2,B2) &
    A1=<B1 & A2=<B2 &
    (A1>A2 & B1=<B2 or A1>=A2 & B1<B2).

% improved nsubset/2 ("not subset")
 insubset(S1,S2) :-
    prolog_call((nonvar(S1), S1=int(A1,B1), nonvar(S2), S2=int(A2,B2),!, R=intint ; R=gen)) &
    (R==intint & intint_nsubset(S1,S2)
     or
     R==gen & nsubset(S1,S2)
    ).
 intint_nsubset(S1,S2) :-
    S1=int(A1,B1) &
    S2=int(A2,B2) &
    A1=<B1 & A2=<B2 &
    (A1<A2 or B2<B1).

  
% improved inters/3
 iinters(S1,S2,S3) :-   
    prolog_call((nonvar(S1), S1=int(A1,B1), nonvar(S2), S2=int(A2,B2),!, R=intint ; R=gen)) &
    (R==intint & intint_inters(S1,S2,S3)
     or
     R==gen & inters(S1,S2,S3)
    ). 
 intint_inters(S1,S2,S3) :-
    S1=int(A1,B1) &
    S2=int(A2,B2) &
    max(A1,A2,A3) &
    min(B1,B2,B3) &
    (A3>B3 & S3={} 
     or
     A3=<B3 & S3=int(A3,B3)
    ).

 max(A,B,A) :-
    A >= B.
 max(A,B,B) :-
    A < B.

 min(A,B,A) :-
    A =< B.
 min(A,B,B) :-
    A > B.


    
