\documentclass[a4paper,10pt]{report}

\usepackage[utf8]{inputenc}
\usepackage{fancyhdr}
\usepackage{graphicx}
\usepackage{z-eves}
\usepackage[spanish]{babel}

\newenvironment{scaption}[1]{\caption{{\small #1}}}{}

\newenvironment{desig}{\begin{list}{}{\setlength{\labelsep}{0cm}\setlength{\labelwidth}{0cm}\setlength{\listparindent}{0cm}\setlength{\rightmargin}{\leftmargin}}}{\end{list}}


\title{Guía de Módulos de Fastest}
\author{Pablo Rodriguez Monetti}
\date{2011}

\begin{document}
 \maketitle


% EMPIEZA CLIENT



\chapter{Client}
Este módulo lógico agrupa los módulos que implementan la funcionalidad de los clientes (en el sentido del paradigma Cliente-Servidor) del sistema Fastest. Se optó por dividir a Client, separando en dos módulos diferentes, aspectos de la lógica de negocios de aquellos de la lógica de presentación. También hay un tercer submódulo, AbstractOrder, que brinda una interfaz que abstrae la implementación del patrón de diseño Command.
	\section{ClientBusinessLogic}
	Aquí se agrupan los módulos que se encargan de las tareas de negocio del lado del cliente del sistema. Tales aspectos se separan en dos módulos, de acuerdo a si involucra funciones de gestión y comunicación en el sistema o a otras funciones propias del dominio de la aplicación y que tienen que ver con el proceso de testing propiamente dicho.
		\subsection{ClientManagement}
			Subsistema encargado de administrar la comunicación entre clientes y servidores de Fastest y de manejar el flujo de control interno en los clientes.
			\subsubsection{Communication}	
			Módulo lógico que agrupa a aquellos otros relacionados con la comunicación entre clientes y servidores del sistema y con el registro de servidores.
				\paragraph{CServersControl}
				Módulo físico que mantiene y gestiona el almacén con la configuración de cada servidor de cómputo del sistema. Sus elementos son de tipo ServerConfig. El módulo está basado en el patrón de diseño Singleton por lo que debe crearse una única instancia de él.
				\paragraph{CServersConfigLoader}
				Módulo físico que tiene la responsabilidad de cargar la configuración de los servidores de cómputo en la única instancia del CServersControl, desde el servidor de datos o desde un archivo de configuración. Oculta la implementación del algoritmo que realiza tal tarea, que actualmente consiste en la lectura de un archivo de configuración.
				\paragraph{DServerConfig}
				Módulo físico que oculta la estructura de datos y los algoritmos que implementan la configuración sobre el servidor de datos del sistema. Estos datos, los imprescindibles para que el cliente se conecte con el servidor de datos, se almacenan en un archivo de configuración. El módulo DServerConfig está basado en el patrón de diseño Singleton por lo que debe crearse una única instancia de él.
				\paragraph{ServerConfig}
				Módulo físico que oculta la estructura de datos y los algoritmos que implementan la configuración necesaria para conectarse con un servidor (tanto de datos como de cómputo), como ser su nombre, dirección IP y puerto sobre el que está esperando una nueva conexión.
				\paragraph{ServerConfigRepository}
				Módulo físico que oculta la estructura de datos y los algoritmos que implementan un agregado o repositorio de instancias de ServerConfig.
				\paragraph{ServerName}
				Módulo físico que representa el nombre de Servidor de Cómputo del Sistema. Se usa por comodidad en la descripción del sistema y no se implementa.
				\paragraph{SocketWriter}
				Módulo físico encargado de escribir información en un flujo de salida(en este caso un Socket) relacionada con la generación de casos de prueba. Cualquier modificación en el protocolo de comunicación Cliente/Servidor de Fastest implicará cambios en este módulo. El módulo oculta detalles del protocolo Cliente/Servidor subyacente así como también los algoritmos y estructuras de datos empleados para cumplir con su funcionalidad. 
				\paragraph{ServiceMediator}
				Módulo físico cuya funcionalidad es establecer la conexión directa (a través de una interfaz de socket) de distintos componentes de la aplicación cliente del sistema con los servidores de cómputo, codificando los pedidos que puedan realizar y decodificando los resultados antes de enviárselos de regreso. Interactúa con el módulo SocketWriter para enviar la información pertinente a los servidores. El módulo oculta los algoritmos que implementan tales funciones. Debe crearse una nueva instancia de este módulo para cada solicitud de servicio que un componente del cliente del sistema efectúe.
			\subsubsection{ImplicitInvocation}
			Es el módulo lógico que contiene aquellos módulos relacionados con la invocación implícita de subrutinas y con los componentes sobre los que se pueden invocar tales subrutinas.
				\paragraph{Events}
				Módulo lógico que agrupa aquellos módulos que implementan eventos. Events se divide en módulos de acuerdo a los distintos tipos de eventos que pueden lanzar un componente del sistema. Para agregar un nuevo evento a Fastest se debe definir un nuevo heredero de Event\_.
					\begin{enumerate}
					\item{AbstractionFuncLoaded. Módulo físico que oculta la estructura de datos y los algoritmos que implementan el evento que debe ser lanzado cuando se haya cargado la función de abstracción necesaria para abstraer casos de prueba concretos. El módulo es heredero del módulo Event\_ dado que representa un evento particular.}
					\item{AllTCasesRequested. Módulo físico que oculta la estructura de datos y los algoritmos que implementan el evento que debe ser lanzado cuando se ordene la generación de todos los casos de prueba. Se lanzará una instancia de este evento por cada árbol de prueba que haya sido generado previamente. El módulo es heredero del módulo Event\_ dado que representa un evento particular.}
					\item{AllTCasesGenerated. Módulo físico que oculta la estructura de datos y los algoritmos que implementan el evento que debe ser lanzado cuando se haya concluido el intento de generación de todos los casos de prueba solicitados. El módulo es heredero del módulo Event\_ dado que representa un evento particular.}
					\item{AllTTreesGenerated. Módulo físico que oculta la estructura de datos y los algoritmos que implementan el evento que debe ser lanzado cuando se haya concluido el intento de generación de todos los árboles de prueba solicitados. El módulo es heredero del módulo Event\_ dado que representa un evento particular.}
					\item{Event\_. Módulo físico que oculta la estructura de datos y los algoritmos que implementan un evento.}
					\item{NotTClassLeavesFounded. Módulo físico que oculta la estructura de datos y los algoritmos que implementan el evento que debe ser lanzado cuando se ha recorrido un árbol de pruebas para buscar sus hojas y no se ha encontrado ninguna. El módulo es heredero del módulo Event\_ dado que representa un evento particular.}	
					\item{OutputAbstracted. Módulo físico que oculta la estructura de datos y los algoritmos que implementan el evento que debe ser lanzado después de abstraer la salida concreta que resulta de ejecutar un caso de prueba de cierta operación. El módulo es heredero del módulo Event\_ dado que representa un evento particular.}
					\item{RefinementFuncLoaded. Módulo físico que oculta la estructura de datos y los algoritmos que implementan el evento que debe ser lanzado cuando se haya cargado la función de refinamiento necesaria para refinar casos de prueba abstractos. El módulo es heredero del módulo Event\_ dado que representa un evento particular.}
					\item{SpecLoaded. Módulo físico que oculta la estructura de datos y los algoritmos que implementan el evento que debe ser lanzado cuando se haya cargado la especificación del programa a testear. El módulo es heredero del módulo Event\_ dado que representa un evento particular.}
					\item{TCaseChecked. Módulo físico que oculta la estructura de datos y los algoritmos que implementan el evento que debe ser lanzado después de haber analizado la correspondencia entre un caso de prueba abstracto y la salida abstracta que corresponde a su ejecución junto con la especificación de la operación. El módulo es heredero del módulo Event\_ dado que representa un evento particular.}
					\item{TCaseExecuted. Módulo físico que oculta la estructura de datos y los algoritmos que implementan el evento que debe ser lanzado después de haber ejecutado un caso de prueba concreto de cierta operación a testear. El módulo es heredero del módulo Event\_ dado que representa un evento particular.}
					\item{TCaseGenerated. Módulo físico que oculta la estructura de datos y los algoritmos que implementan el evento que debe ser lanzado después de haberse terminado el intento de generación del caso de prueba abstracto de cierta clase de prueba de una operación particular. El módulo es heredero del módulo Event\_ dado que representa un evento particular.}
					\item{TCaseRefined. Módulo físico que oculta la estructura de datos y los algoritmos que implementan el evento que debe ser lanzado después de haber refinado un caso de prueba abstracto. El módulo es heredero del módulo Event\_ dado que representa un evento particular.}
					\item{TCaseRequested. Módulo físico que oculta la estructura de datos y los algoritmos que implementan el evento que debe ser lanzado al solicitar el cálculo de un caso de prueba para cierta clase de prueba. El módulo es heredero del módulo Event\_ dado que representa un evento particular.}
					\item{TCaseStrategySelected. Módulo físico que oculta la estructura de datos y los algoritmos que implementan el evento que debe ser lanzado después de que el usuario selecciona la estrategia de generación de casos de prueba que desea. El módulo es heredero del módulo Event\_ dado que representa un evento particular.}
					\item{TTreeGenerated. Módulo físico que oculta la estructura de datos y los algoritmos que implementan el evento que debe ser lanzado después de generarse el árbol de prueba de cierta operación. El módulo es heredero del módulo Event\_ dado que representa un evento particular.}
					\item{PruneTTreeRequested. Módulo físico que oculta la estructura de datos y los algoritmos que implementan el evento que debe ser lanzado cuando se ordena la poda del arbol de prueba. El módulo es heredero del módulo Event\_ dado que representa un evento particular.}
					\item{PruneTClassRequested. Módulo físico que oculta la estructura de datos y los algoritmos que implementan el evento que debe ser lanzado cuando se ordena la poda de una clase de prueba. El módulo es heredero del módulo Event\_ dado que representa un evento particular.}
					\item{PrunningResult. Módulo físico que oculta la estructura de datos y los algoritmos que implementan el evento que debe ser lanzado anunciando el analisis de factibilidad de la poda de una clase de prueba. El módulo es heredero del módulo Event\_ dado que representa un evento particular.}
					\end{enumerate}
				\paragraph{EventAdmin}
				Módulo físico cuya funcionalidad corresponde a la del administrador de eventos de la aplicación Cliente del sistema, y que permite tanto leer un archivo de configuración de invocación implícita par construir la tabla de eventos como anunciar un evento y llamar a las subrutinas interesadas en él. El módulo está basado en el patrón de diseño Singleton por lo que debe crearse una única instancia de él. Oculta las estructuras de datos y los algoritmos para implementar tales tareas.
				\paragraph{EventName}
				Módulo físico que representa el nombre de un evento del Sistema. Se usa por comodidad en la descripción del sistema y no se implementa.
				\paragraph{EventTable}
				Módulo físico que oculta la estructura de datos y los algoritmos que implementan un agregado o repositorio de instancias de Subscriptor.
				\paragraph{IIComponent}
				Interfaz que oculta la estructura de datos y los algoritmos que implementan un componente del sistema que puede estar interesado en eventos de invocación implícita. En principio, las instancias de los herederos de éste módulo corresponden a los componentes mostrados en la última figura del documento Introducción a la Arquitectura del Sistema Fastest. Cada instancia mantiene una referencia a la interfaz de usuario del sistema para poder interactuar con ella en caso de ser necesario. En principio solo un heredero de IIComponent, Controller, será responsable de actuar sobre la interfaz de usuario, por lo que será el único de ellos que haga uso de la mencionada referencia.
				\paragraph{IIOrder}
				Módulo físico que hereda de AbstractOrder y que contiene una implementación concreta de tal módulo. Tal implementación es utilizada en todo el subsistema de Invocación Implícita para referirse a las subrutinas de ciertos módulos, que deben ser invocadas en respuesta al anuncio de algún evento de interés. IIOrder mantiene en su estado una referencia a la instancia del componente (módulo IIComponent) sobre el que se invocará la subrutina, el nombre de la subrutina a invocar, y una referencia al evento anunciado.
				\paragraph{MethodName}
				Módulo físico que representa el nombre de un método de componente de invocación implícita. Se usa por comodidad en la descripción del sistema y no se implementa.
				\paragraph{Subscriptor}
				Módulo físico que oculta las estructuras de datos y los algoritmos que implementan la subscripción de una subrutina de cierto módulo para ser invocada al lanzarse determinado evento.
			\subsubsection{Controller}
			Módulo físico que tiene la responsabilidad de mantener referencias a:
			\begin{itemize}
			 \item árboles de pruea previamente calculados
			 \item casos de prueba previamente calculados
 			 \item especificación cargada por el usuario
			 \item especificación con los esquemas expandidos
			 \item lista de operaciones a ser testeadas, junto con las tácticas que se le aplicarán a cada una
			 \item cantidad de clases de prueba para las que se está intentando obtener un caso de prueba
			 \item cantidad de clases de prueba que se están analizando para verificar que son o no son vacías
			 \item valores asignados a variables definidas en definiciones axiomáticas
			 \item variables, definidas en definiciones axiomáticas, que esperan un valor por parte del usuario
			 \item para cada variable, definida en alguna definición axiomática, los predicados, de definciones axiomáticas, que la contienen
			 \item las variables de tipo no básico, definidas en definiciones axiomáticas, contenidas en cada predicado
			 \item la lista de declaraciones de constantes auxiliares que se introducen para definir el valor de alguna variable definida en alguna definición axiomáticas
			 \item la lista de variables, entre las dadas en definiciones axiomáticas y que esperan un valor del parte del usuario, cuyos valores no pueden ser seteadas via un comando setaxdef debido a que aparecen en el predicado de alguna clase de prueba previamente podada
			 \item etc...
			\end{itemize}
			Este módulo oculta las estructuras de datos y algoritmos para llevar a cabo las tareas mencionadas. Controller hereda del módulo IIComponent ya que resulta ser una implementación particular de él: puede interesarse en eventos de invocación implícita.
		\subsection{Testing}
		Módulo lógico que agrupa aquellos módulos relacionados con el proceso de testing funcional basado en especificaciones Z.
			\subsubsection{ClientTCaseChecking}
			Módulo lógico que agrupa a aquellos otros vinculados a la comprobación de correspondencia entre un caso de prueba abstracto de cierta operación, la operación, y la salida abstracta que surge de ejecutar el caso de prueba abstracto. Dado que dicha comprobación se realiza en servidores de cómputo, este módulo sólo es responsable de la solicitud de tales servicios.
				\paragraph{TCaseCheckerClient}
				Módulo físico cuya funcionalidad es manejar las solicitudes, a servidores de cómputo, de comprobación de correspondencias entre casos de prueba abstracto de operacion, las correspondientes operaciones, y las salidas abstracta que surgen de ejecutar los casos de prueba abstractos. Cada solicitud se realiza en un thread diferente para favorecer cuestiones de performance, ejecutando en cada thread la subrutina run() del módulo TCaseCheckerClientRunner. El módulo TCaseCheckerClient oculta los algoritmos que implementan la funcionalidad comentada y hereda del módulo IIComponent ya que resulta ser una implementación particular de él.
				\paragraph{TCaseCheckerClientRunner}
				Módulo físico que se encarga de solicitar, a un servidor de cómputo, una comprobación de correspondencia entre un caso de prueba abstracto de una operación, la operación, y la salida abstracta que surge de ejecutar el caso de prueba abstracto. El módulo devuelve el resultado a través del anuncio de un evento de tipo TCaseChecked y oculta los algoritmos que implementan las tareas mencionadas.
			\subsubsection{ClientPrunning}
			Módulo lógico que agrupa a aquellos otros relacionados con la poda de clases de prueba y cuyas instancias siempre corren del lado del cliente. Dado que la poda de clases de prueba se realiza en servidores de cómputo, este módulo es sólo responsable de la solicitud de tales servicios y no de su realización.
				\paragraph{PrePruner}
				Módulo físico que permite determinar si una clase de prueba es vacía por tener en su predicado una contradicción booleana, esto es, un predicado de la forma $p \land \lnot p$. El módulo oculta el algoritmo que implementa esta funcionalidad.
				\paragraph{TClassPruneClient}
				Módulo físico cuyas instancias (aunque se asume que existirá sólo una) se interesan en los eventos de tipo PruneTClassRequested, anunciados por una instancia de TPrunning, cada uno de los cuales es una solicitud de poda de una clase de prueba. TClassPruneClient se encarga de manejar estas solicitudes procesando cada una en un thread diferente para favorecer cuestiones de performance, ejecutando la subrutina run() del módulo TClassPruneClientRunner en cada nuevo thread. El módulo TClassPruneClient oculta los algoritmos que implementan dicha funcionalidad. Hereda del módulo IIComponent ya que resulta ser una implementación particular de él.
				\paragraph{TClassPruneClientRunner}
				Módulo físico que se encarga de solicitar, a un servidor de cómputo, el análisis del predicado de una clase de prueba, para verificar si es o no es una contradicción. En caso que lo sea la clase de prueba podrá podarse del árbol de pruebas al que pertenece. Cada solicitud debe hacerse a través de una nueva instancia de ServiceMediator, que es la que mantiene el secreto de cómo se lleva a cabo la comunicación con los servidores. El módulo TClassPruneClientRunner devuelve el resultado a través del anuncio de un evento de tipo PrunningResult, y oculta los algoritmos que implementan las tareas mencionadas.
				\paragraph{TPrunning}
				Módulo físico cuyas instancias (aunque se asume que existirá sólo una) manejan eventos de tipo PruneTTreeRequested y anuncian eventos de tipo PruneTClassRequested. El primer evento tiene como parámetro un árbol de pruebas que se quiere podar, el segundo evento tiene lleva una clase de prueba cuyo predicado se quiere analizar para determinar si es o no una contracción. Cada clase de prueba será una clase de prueba del árbol de pruebas o una modificación de una de ellas, reemplazando definiciones axiomáticas por los valores que les corresponden y agregando declaraciones de constantes que puedan estar contenidas en estos valores. Estas modificaciones se realizarán en este módulo TPrunning, el cual oculta los algoritmos y estructuras de datos necesarios para cumplir con la funcionalidad comentada.
			\subsubsection{ClientTCaseGeneration}
			Módulo lógico que agrupa a aquellos otros módulos relacionados a la generación de casos de prueba abstractos del lado del cliente, es decir, módulos que hacen las solicitudes, a  servidores de cómputo del sistema, del cálculo de casos de prueba abstractos.
				\paragraph{TCaseGenClient}
				Módulo físico que se encarga de manejar las solicitudes, a servidores de cómputo, de generación de casos de prueba abstractos. Estas solicitudes son indicadas en cada evento de tipo TCaseRequested que se anuncie en el sistema, y son procesadas por TCaseClient en un thread diferente para favorecer cuestiones de performance, ejecutando la subrutina run() del módulo TCaseGenClientRunner en cada nuevo thread. El módulo TCaseGenClient oculta los algoritmos que implementan dicha funcionalidad. Hereda del módulo IIComponent ya que resulta ser una implementación particular de él.
				\paragraph{TCaseGenClientRunner}
				Módulo físico que se encarga de solicitar, a un servidor de cómputo, la generación de un caso de prueba abstracto para cierta clase de prueba de un árbol de prueba de una operación. Cada solicitud debe hacerse a través de una nueva instancia de ServiceMediator, que es la que mantiene el secreto de cómo se lleva a cabo la comunicación con los servidores. El módulo TCaseGenClientRunner devuelve el resultado a través del anuncio de un evento de tipo TCaseGenerated, y oculta los algoritmos que implementan las tareas mencionadas.
				\paragraph{TClassExtractor}
				Módulo físico que se encarga de procesar eventos de tipo AllTCasesRequested (aquellos que tienen como parámetro un arbol de prueba, junto con el nombre de la operación) lanzando, para cada uno, sucesivos eventos de tipo TCaseRequested, uno para cada clase de prueba que sea hoja del árbol correspondiente. Cada evento TCaseRequested que TClassExtractor anuncia tendrá como parámetros el nombre de la operación y la clase de prueba que corresponda. No se procesan las ramas que aparezcan podadas en los árboles. El módulo TClassExtractor oculta los algoritmos que implementan estas tareas. Hereda del módulo IIComponent ya que resulta ser una implementación particular de él.
			\subsubsection{ClientAbstraction}
			Módulo lógico que agrupa elementos del lado del cliente vinculados a la abstracción de casos de prueba a nivel de implementación en casos de prueba a nivel de especificación.
				\paragraph{TCaseNodeAdderClient}
				Módulo físico que se encarga de manejar las solicitudes para agregar a los casos concretos el codigo necesario para capturar la salida de las variables. Estas solicitudes son indicadas en cada evento de tipo TCaseAddCaptureCodeRequested que se anuncie en el sistema, y son procesadas por TCaseNodeAdderClient en un thread diferente para favorecer cuestiones de performance, ejecutando la subrutina run() del módulo TCaseNodeAdderClientRunner en cada nuevo thread. El módulo TCaseNodeAdderClient oculta los algoritmos que implementan dicha funcionalidad.
				\paragraph{TCaseNodeAdderClientRunner}
				Módulo físico que se encarga de interactuar con los módulos adecuados para agregar el código de captura a un caso concreto en particular. De acuerdo al lenguaje objetivo crea el heredero correcto de ScriptTestWriter y le pasa como parámetro las variables que deben ser monitoreadas para que se agregue el código de captura. Oculta los algoritmos y las estructuras de datos empleados para tal fin.
				\paragraph{TCaseAbsClient}
				Módulo físico que se encarga de manejar las solicitudes de abstraccion de casos concretos. Estas solicitudes son indicadas en cada evento de tipo TCaseAbstractRequested que se anuncie en el sistema, y son procesadas por TCaseAbsClient en un thread diferente para favorecer cuestiones de performance, ejecutando la subrutina run() del módulo TCaseAbsClientRunner en cada nuevo thread. El módulo TCaseAbsClient oculta los algoritmos que implementan dicha funcionalidad.
				\paragraph{TCaseAbsClientRunner}
				Módulo físico que se encarga de interactuar con los módulos adecuados para completar la abstracción de un caso concreto. Básicamente solicita al módulo XMLParser para que parsee los archivos XML que deben haber sido generados en la etapa de ejecucion y finalmente le pasa los resultados del parseo al módulo ASTAbstraction para que complete el proceso.
				Oculta los algoritmos y estructuras de datos empleados para cumplir con su función.
				\paragraph{ManipulersFactory}
				Interfaz creada siguiendo los lineamientos del patrón de diseño AbstractFactory que tendrá un heredero por cada lenguaje que soporte Fastest en la etapa de abstracción. Se utiliza para evitar inconsistencias relacionadas con el lenguaje objetivo.
				\paragraph{ManipulersFactoryC}
				Módulo físico que hereda de ManipulersFactory y se encarga de crear los objetos necesarios para la abstracción relacionados exclusivamente con el lenguaje de programación C.
				\paragraph{AbstractionLawRepository}
				Módulo físico que almacena las leyes de abstracción cargadas al sistema como instancias de objetos AbstractionLaw.
				Oculta las estructuras de datos empleadas.
			\subsubsection{TCaseExecution}
			Módulo lógico que agrupa a aquellos otros módulos vinculados a la ejecución de casos de prueba.
				\paragraph{ConcreteOutput}
				Módulo físico que oculta la estructura de datos y los algoritmos que implementan el resultado concreto (a nivel de implementacíón), que se obtiene de ejecutar un caso de prueba.
				\paragraph{ConcreteTCase}
				Módulo físico que oculta la estructura de datos y los algoritmos que implementan un caso de prueba concreto (a nivel de implementación).
				\paragraph{Executor}
				Módulo físico cuya responsabilidad es ejecutar casos de prueba sobre el programa a ser testeado. Oculta las estructuras de datos y los algoritmos necesarios para implementar la mencionada tarea. Hereda del módulo IIComponent ya que resulta ser una implementación particular de él.
			\subsubsection{TCaseRefinement}
			Módulo lógico que agrupa elementos vinculado al refinamiento de casos de prueba abstractos en casos de prueba concretos.
				\paragraph{TCaseRefClient}
				Módulo físico que se encarga de manejar las solicitudes de refinamiento de casos de prueba abstractos. Estas solicitudes son indicadas en cada evento de tipo TCaseRefineRequested que se anuncie en el sistema, y son procesadas por TCaseRefClient en un thread diferente para favorecer cuestiones de performance, ejecutando la subrutina run() del módulo TCaseRefClientRunner en cada nuevo thread. El módulo TCaseRefClient oculta los algoritmos que implementan dicha funcionalidad. Hereda del módulo IIComponent ya que resulta ser una implementación particular de él.
				\paragraph{TCaseRefClientRunner}
				Módulo físico que se encarga de solicitar, a un servidor de cómputo, el refinamiento de un caso de prueba a un lenguaje en particular. Este módulo se encargará de parsear el archivo con la ley de refinamiento y posteriormente solicitará al módulo RefineAST el refinamiento en cuestión. Finalmente anuncia el caso refinado a través de un evento de tipo TCaseRefined.
				\paragraph{ConcreteTCase}
				Módulo físico que abstrae un caso refinado. Almacena el codigo en el lenguaje de programacion indicado con la inicializacion de las variables que se indicaron en la ley de refinamiento, asi como tambien almacena informacion relacionada al caso abstracto del cual refinado, el lenguaje que se empleo para su refinamiento, el nombre de la ley de refinamiento, etc. Oculta los algoritmos y estructuras de datos utilizados para su implementacion. 
				\paragraph{ConstantGenerator}
				Módulo físico que se encarga de generar constantes de tipos primitivos de un lenguaje de programacion a partir de un objeto de CZT. Los resultados serán además almacenados en la instancia única de ConstantStore para su posterior uso en el proceso de abstracción.
				Oculta los algoritmos empleados para la implementacion.
				\paragraph{ConstantStore}
				Módulo físico que se encarga de mapear expresiones de CZT con constantes de tipos primitivos de los lenguajes de programacion soportados por Fastest en la etapa de refinamiento.
				Oculta los algoritmos y estructuras de datos empleadas para la implementacion.
				\paragraph{RefineAST}
				Módulo físico que se encarga de el refinamiento propiamente dicho. Parte de una ley de refinamiento parseada y un caso abstracto y va interactuando con un heredero adecuado del modulo RefineExpr hasta obtener una instancia de ConcreteTCase.
				Oculta los algoritmos y estructuras de datos empleadas para la implementacion.
				\paragraph{RefineExpr}
				Interfaz de la cual heredarán los módulos que se encargan de obtener el código en un lenguaje de programación en particular necesario para inicializar las variables indicadas en las reglas de refinamiento que reciben como parámetro. Tendrá un heredero por cada lenguaje de programación que soporte Fastest en esta étapa.
				\paragraph{RefineExprC}
				Modulo físico que implementa la interfaz RefineExpr. Se encarga de generar código C para inicializar las variables que se le indican en la regla de refinamiento que se le pasa como parámetro.
				Oculta los algoritmos y estructuras de datos empleadas para la implementacion.
				\paragraph{RefineExprJava}
				Modulo físico que implementa la interfaz RefineExpr. Se encarga de generar código Java para inicializar las variables que se le indican en la regla de refinamiento que se le pasa como parámetro.
				Oculta los algoritmos y estructuras de datos empleadas para la implementacion.
				\paragraph{RefLawRepository}
				Modulo físico que almacena las leyes de refinamiento sin parsear cargadas en Fastest.
				Oculta los algoritmos y estructuras de datos empleadas para la implementacion.
				\paragraph{TCaseAssignment}
				Modulo físico que almacena código de inicialización de una variable en un lenguaje de programación.
				Oculta los algoritmos y estructuras de datos empleadas para la implementacion.
				\paragraph{TCRL\_Parser}
				Modulo físico que se encarga de parsear una ley de refinamiento. Este módulo fue creado por Java Compiler Compiler a partir del archivo tcrl.jj presente en el sistema.
				Toma un archivo y devuelve el AST resultante de parsear dicho archivo.
				Oculta los algoritmos y estructuras de datos empleadas para la implementacion.
				\paragraph{TCRL\_PreProcessor}
				Modulo físico que se encarga de reemplazar el uso de sinonimos en un objeto de tipo TCRL\_AST por los objetos correspondientes.
				Oculta los algoritmos y estructuras de datos empleadas para la implementacion.
				\paragraph{TCRL\_Parser}
				Modulo físico que se encarga de reemplazar los sinonimos en una ley de refinamiento parseada por las expresiones con las cuales se corresponden.
				Oculta los algoritmos y estructuras de datos empleadas para la implementacion.
				\paragraph{RefinementUtils}
				Modulo físico que brinda funcionalidades comunes al proceso de refinamiento.
				Oculta los algoritmos y estructuras de datos empleadas para la implementacion.
			\subsubsection{TTreeModules}
			Módulo lógico que agrupa a aquellos otros relacionados con los árboles de prueba y su generación. Se divide de acuerdo a las distintas tácticas que pueden aplicarse para generar árboles de prueba, a los módulos que implementen Visitantes (patrón de diseño Visitor) para aplicar operaciones sobre ellos y a otros módulos relacionados. 
				\paragraph{Tactics}
				Módulo lógico cuyos submódulos implementan tácticas de generación de clases de prueba o información sobre éstas tácticas. Las nuevas tácticas que puedan agregarse al sistema deberán ser módulos herederos de Tactic.
					\begin{enumerate}
						\item{AbstractTactic. Módulo físico que oculta la estructura de datos y los algoritmos que una táctica abstracta. Implementa los métodos de Tactic cuya implementación es la misma independientemente de la táctica específica. Este módulo es heredero del módulo Tactic dado que implementa algunas de sus funcionalidades.}
						\item{CEPTactic. Módulo físico que oculta la estructura de datos y los algoritmos que implementan la táctica de proyección causa-efecto (Cause Effect Propagation). Este módulo es heredero del módulo Tactic dado que representa y permite aplicar un tipo de táctica particular.}
						\item{CEPTacticInfo. Módulo físico que mantiene información relacionada a la táctica de proyección causa-efecto aplicada. Oculta las estructuras de datos y algoritmos que implementan tal información y hereda del módulo TacticInfo.}
						\item{DNFIterator} Módulo físico que facilita la implementación de la táctica Disjunctive Normal Form (DNF). Permite solicitarle los términos de la disyunción uno a uno. A través de este módulo se logra no tener que almacenar el predicado en DNF completo sino solamente una lista de predicados en DNF que, si se combinan en conjunción sus elementos, es equivalente al predicado en DNF. La lista de predicados en DNF es calculada con el modulo DNFPredExtractor. 
						\item{DNFTactic. Módulo físico que oculta la estructura de datos y los algoritmos que implementan la táctica DNF (Disjunctive Normal Form). Este módulo es heredero del módulo Tactic dado que representa y permite aplicar un tipo de táctica particular.}
						\item{DNFTacticInfo. Módulo físico que mantiene información relacionada a la táctica DNF aplicada. Oculta las estructuras de datos y algoritmos que implementan tal información y hereda del módulo TacticInfo.}
						\item{FTTactic. Módulo físico que oculta la estructura de datos y los algoritmos que implementan la táctica de tipos libres (Free Types). Este módulo es heredero del módulo Tactic dado que representa y permite aplicar un tipo de táctica particular.}
						\item{FTTacticInfo. Módulo físico que mantiene información relacionada a la táctica de tipos libres, como ser el nombre de la variable a partir de cuyo tipo se van a generar nuevas clases de prueba y una referencia a la instancia de Freetype, en la especificación cargada en Fastest, que corresponde al tipo. Oculta las estructuras de datos y algoritmos que implementan tal información y hereda del módulo TacticInfo.}
						\item{SISETactic. Módulo físico que oculta la estructura de datos y los algoritmos que implementan la táctica Set In Set Extension (SISE). Este módulo es heredero del módulo Tactic dado que representa y permite aplicar un tipo de táctica particular.}
						\item{SISETacticInfo. Módulo físico que mantiene información relacionada a la táctica SISE, como ser el nombre de la variable a partir de la cual se van a generar nuevas clases de prueba y una referencia al conjunto definido por extensión al cual pertenece la variable antes mencionada. Oculta las estructuras de datos y algoritmos que implementan tal información y hereda del módulo TacticInfo.}
						\item{SSSETactic. Módulo físico que oculta la estructura de datos y los algoritmos que implementan la táctica Sub Set of Set Extension (SSSE). Este módulo es heredero del módulo Tactic dado que representa y permite aplicar un tipo de táctica particular.}
						\item{SSSETacticInfo. Módulo físico que mantiene información relacionada a la táctica SSSE, como ser el nombre de la variable a partir de la cual se van a generar nuevas clases de prueba y una referencia al conjunto definido por extensión del cual es subconjunto la variable antes mencionada. Oculta las estructuras de datos y algoritmos que implementan tal información y hereda del módulo TacticInfo.}
						\item{PSSETactic. Módulo físico que oculta la estructura de datos y los algoritmos que implementan la táctica Proper Subset of Set Extension (PSSE). Este módulo es heredero del módulo Tactic dado que representa y permite aplicar un tipo de táctica particular.}
						\item{PSSETacticInfo. Módulo físico que mantiene información relacionada a la táctica PSSE, como ser el nombre de la variable a partir de la cual se van a generar nuevas clases de prueba y una referencia al conjunto definido por extensión del cual es subconjunto la variable antes mencionada. Oculta las estructuras de datos y algoritmos que implementan tal información y hereda del módulo TacticInfo.}
						\item{SMTactic. Módulo físico que oculta la estructura de datos y los algoritmos que implementan la táctica de mutación de especificaciones Z (Specification Mutation). Este módulo es heredero del módulo Tactic dado que representa y permite aplicar un tipo de táctica particular.}
						\item{SMTacticInfo. Módulo físico que mantiene información relacionada a la táctica de mutación de especificaciones aplicada, como por ejemplo, la operación mutante que junto a la operación original permitirá aplicar la mencionada táctica. Oculta las estructuras de datos y algoritmos que implementan tal información y hereda del módulo TacticInfo.}
						\item{SPTactic. Módulo físico que oculta la estructura de datos y los algoritmos que implementan la táctica de particiones estándar de operadores (Standard Partition). Este módulo es heredero del módulo Tactic dado que representa y permite aplicar un tipo de táctica particular.}
						\item{SPTacticInfo. Módulo físico que mantiene información relacionada a la táctica de particiones estándar de operadores, como ser el predicado (de cierto esquema de operación) o el operador sobre el que se aplicó la partición. Oculta las estructuras de datos y algoritmos que implementan tal información y hereda del módulo TacticInfo.}
						\item{StdPartition. Módulo físico que representa una partición estándar de un operador del lenguaje de especificaciones Z. Oculta los algoritmos y estructuras de datos que la implementan.}
						\item{StdPartitionLoader. Módulo encargado de parsear el archivo de configuración que contiene la definición de las particiones estándar del sistema, y que las almacena como instancias de StdPartition en la instancia única de StdPartitionsControl que hay en el Sistema. StdPartitionLoader oculta los algoritmos y estructuras de datos que llevan a cabo la funcionalidad mencionada.}
						\item{StdPartitionsControl. Módulo que permite agrupar una serie de instancias de StdPartition. Debe haber una única instancia de StdPartitionsControl en el sistema en cada momento.	}
						\item{Tactic. Interfaz que abstrae la estructura de datos y algoritmos que implementan una táctica y que permite aplicarla a una clase de prueba Z obteniendo las clases de prueba resultantes.}
						\item{TacticInfo. Módulo físico que permite obtener información relevante de una táctica de testing aplicada, como ser su identificador de táctica y demás argumentos que se precisen. El módulo oculta las estructuras de datos y algoritmos que implementan tal información.}
					\end{enumerate}
				\paragraph{TTreeStrategies}
				Módulo lógico que agrupa aquellos módulos que implementen estrategias de generación de árboles de prueba.
					\begin{enumerate}
						\item{IterativeTTreeStrategy. Módulo físico que oculta la estructura de datos y los algoritmos que implementan la estrategia iterativa de generación de casos de prueba. Esta estrategia se basa en aplicar las tácticas de testing (de la lista dada) una a una por cada nuevo nivel que se vaya generando en el árbol de pruebas. Este módulo es heredero del módulo TTreeStrategy dado que representa una estrategia particular de generación de árboles de prueba.}
						\item{TTreeStrategy.Interfaz que abstrae las estructuras de datos y el algoritmo que implementa una estrategia de aplicación de tácticas en la generación del árbol de prueba de una operación. Este módulo fue concebido en base al patrón de diseño Strategy. Las distintas estrategias que pueden aplicarse deberán ser implementadas por módulos que, a su vez, implementen esta interfaz. Dados un esquema de operación Z y una lista de tácticas de testing, cada estrategia establece el criterio de selección de la táctica a aplicar, entre las de la lista de tácticas dada, en cada paso del proceso de construcción del árbol de prueba. Una estrategia podría ser aplicar las tácticas de la lista una a una por cada nuevo nivel del árbol de prueba, asumiendo que hay tantas tácticas como niveles posibles. Otra podría ser tener tantas tácticas como clases de prueba internas en el árbol de prueba que se va generando y aplicarlas una a una.}
					\end{enumerate}
				\paragraph{TTreeVisitors}
				Módulo lógico que agrupa aquellos módulos que implementen visitantes (patrón de diseño Visitor) sobre árboles de prueba.
					\begin{enumerate}
						\item{SchemeTTreeFinder. Módulo físico que permite recorrer un árbol de prueba para buscar una clase o caso de prueba particular en él. El esquema buscado debe estar dada/o por el nombre que se pasa como argumento en el contructor de este módulo. También se pasa como argumento un entero que representa el grado de expansión con el que se quiere expandir el esquema devuelto. Esto significa, que una vez encontrado el nodo del árbol para el esquema deseado, este se expanderá tantos niveles hacia arriba en el árbol como indique ese valor. El módulo hereda de TTreeVisitor dado que se implementa como un visitante particular.}
						\item{TCaseNodeAdder. Módulo físico que permite agregar un nodo de tipo TCaseNode como hoja a un árbol de prueba. El constructor del módulo toma el nombre de la clase de prueba del nodo (de tipo TClassNode) padre del nuevo nodo y la instancia de AbstractTCase que corresponde al caso de prueba no expandido que será parte del contenido de este nuevo nodo. La otra parte, el caso de prueba expandido, se determina usando el caso de prueba expandido y la clase de prueba del nodo padre. El módulo hereda de TTreeVisitor dado que se implementa como un visitante particular.}
						\item{TCaseNodeTextUIPrinter. Módulo físico que permite recorrer un árbol de prueba e imprimir todos sus casos de prueba en pantalla mientras se utilice la interfaz de usuario en modo texto. El módulo hereda de TTreeVisitor dado que se implementa como un visitante particular.}
						\item{TClassLeavesFinder. Módulo físico que permite recorrer un árbol de prueba para obtener aquellas clases de prueba que sean hojas del árbol. Estas clases de pruebas son las que resultan de interés a la hora de querer obtener casos de prueba para la operación correspondiente. No se consideran las hojas de los subárboles podados y sí se considera una clase si todas las clases que cuelgan de ella están podadas. El módulo hereda de TTreeVisitor dado que se implementa como un visitante particular.}
						\item{TClassNodeTextUIPrinter. Módulo físico que permite recorrer un árbol de prueba e imprimir todos sus casos de prueba en pantalla mientras se utilice la interfaz en modo texto. El módulo hereda de TTreeVisitor dado que se implementa como un visitante particular.}
						\item{TTreeBelowPruner. Módulo físico que permite recorrer un árbol de prueba para buscar una clase de prueba, especificada a través de su nombre en el constructor del módulo, para marcar sus clases hijas como podadas o como no podadas, según se especifique en el constructor del módulo. TTreeBelowPruner hereda de TTreeVisitor dado que se implementa como un visitante particular.}
						\item{TTreeFromPruner. Módulo físico que permite recorrer un árbol de prueba para buscar una clase de prueba, especificada a través de su nombre en el constructor del módulo, según se especifique en el constructor del módulo. TTreeFromPruner hereda de TTreeVisitor dado que se implementa como un visitante particular.}
						\item{TTreeTextUIPrinter} Módulo físico que permite recorrer e imprimir un árbol de prueba en pantalla mientras se utilice la interfaz en modo texto. Lo que se imprime es el nombre de cada nodo del árbol, no el contenido de cada nodo. Si hay algún nodo que corresponde a una clase de prueba podada, no se imprimen los nodos que cuelgan de él. El módulo hereda de TTreeVisitor dado que se implementa como un visitante particular.
						\item{TTreeVisitor. Interfaz que abstrae los algoritmos que implementan un visitante de árboles de prueba. Permite aplicar una operación particular a los nodos de un árbol de prueba, teniendo de que tipo particular es cada uno.}
					\end{enumerate}
				\paragraph{TacticName}
				Módulo físico que representa el nombre de una táctica de generación de árboles de prueba. Se usa por comodidad en la descripción del sistema y no se implementa.
				\paragraph{TacticManager}
				Módulo físico que se encarga de gestionar definiciones de tácticas de testing funcional, descargándolas desde el servidor de datos o bien agregando nuevas. Oculta los algoritmos que implementan tales tareas. El módulo está basado en el patrón de diseño Singleton por lo que puede crearse una única instancia de él. 
				\paragraph{TCaseNode}
				Módulo físico que oculta la estructura de datos y los algoritmos que implementan un nodo de un árbol de prueba cuyo dato es un caso de prueba abstracto. Más precisamente, cada instancia de TCaseNode mantiene en su estado dos instancias de AbstractTCase que corresponden al caso de prueba abstracto asociado al nodo: una con los esquemas incluídos totalmente expandidos y la otra con los esquemas incluídos totalmente colapsados. Esto se hace por una cuestión de comodidad. El módulo es heredero de TTreeNode, pues representa un tipo particular de nodo árbol de prueba..
				\paragraph{TClassNode}
				Módulo físico que oculta la estructura de datos y los algoritmos que implementan un nodo de un árbol de prueba cuyo dato es una clase de prueba. En la intancia de TClassNode también debe indicarse si el árbol de prueba está podado en esa clase de pruena o no. El módulo TClassNode es heredero de TTreeNode pues representa un tipo particular de nodo de prueba.
				\paragraph{TTreeGen}
				Módulo físico que permite generar el árbol de prueba de una operación determinada de una especificación Z. Oculta las estructuras de datos y los algoritmos que implementan la tarea mencionada. Hereda del módulo IIComponent ya que resulta ser una implementación particular de él.
				\paragraph{TTreeNode}
				Interfaz que abstrae la estructura de datos y los algoritmos que implementan un nodo de un árbol de prueba.

	\section{ClientPresentation}
	Módulo lógico que contiene aquellos módulos vinculados a la lógica de presentación, es decir, aquellos módulos que implementan la interacción entre la lógica de negocio del sistema y el usuario.
		\subsection{Commands}
		Módulo lógico que agrupa a los módulos relacionados con los comandos que puede ejecutar el usuario de Fastest al usar la interfaz en modo texto del sistema.
			\subsubsection{AddTacticCommand}
			Módulo físico que implementa el comando de interfaz de usuario que permite agregar una nueva táctica (junto con sus parámetros, de ser necesario) a la lista de tácticas asociada a una de las operaciones a testear. Oculta algoritmos y estructuras de datos necesarios para lograr su propósito.
			\subsubsection{ApplyCommand}
			Módulo físico que implementa el comando de interfaz de usuario que brinda la posibilidad de aplicar un teorema de eliminación a una clase de prueba. Recibe como parámetro la clase en cuestión, el teorema de eliminación y los parámetros reales. Esto permite determinar si una clase de prueba es una clase vacía para luego podarla y evitar el intento de generación del caso de prueba en vano. Oculta algoritmos y estructuras de datos necesarios para lograr su propósito.
			\subsubsection{Command}
			Interfaz que abstrae un comando de la interfaz de usuario de modo texto del sistema. Cada vez que se necesite agregar un nuevo comando de usuario, debe crearse un heredero del módulo Command.
			\subsubsection{EvalCommand}
			Módulo físico que implementa el comando de interfaz de usuario que que permite evaluar expresiones y predicados Z. Oculta algoritmos y estructuras de datos necesarios para lograr su propósito.
			\subsubsection{GenAllTCasesCommand}
			Módulo físico que implementa el comando de interfaz de usuario que que brinda la funcionalidad de generar (o intentar generar) los casos de prueba de todas las operaciones para las que previamente se generó un árbol de prueba. Oculta algoritmos y estructuras de datos necesarios para lograr su propósito.
			\subsubsection{GenAllTTCommand}
			Módulo físico que implementa el comando de interfaz de usuario que que permite generar los árboles de prueba de todas las operaciones seleccionadas para ser testeadas. Oculta algoritmos y estructuras de datos necesarios para lograr su propósito.
			\subsubsection{LoadRefinementLawCommand}
			Módulo físico que implementa el comando de interfaz de usuario que permite la carga a Fastest de una ley de refinamiento. Recibe como parámetros el nombre de la ley y el path del archivo en el cual se encuentra la ley. Oculta algoritmos y estructuras de datos necesarios para lograr su propósito.
			\subsubsection{LoadSpecCommand}
			Módulo físico que implementa el comando de interfaz de usuario que permite realizar la carga en el sistema de una especificación Z escrita en Latex. Oculta algoritmos y estructuras de datos necesarios para lograr su propósito.
			\subsubsection{PruneBelowCommand}
			Módulo físico que implementa el comando de interfaz de usuario que brinda la posibilidad de podar las clases de prueba, en un árbol de prueba, que cuelgan de una clase de prueba especificada por su nombre. Esto permite evitar el intento de generación de casos de prueba para aquellas clases podadas y para las que cuelgan de ellas. Oculta algoritmos y estructuras de datos necesarios para lograr su propósito.
			\subsubsection{PruneFromCommand}
			Módulo físico que implementa el comando de interfaz de usuario que brinda la posibilidad de podar una clase de prueba, en un árbol de prueba, especificada por su nombre. Esto permite evitar el intento de generación de casos de prueba para aquellas clases podadas y las que cuelgan de ellas. Oculta algoritmos y estructuras de datos necesarios para lograr su propósito.
			\subsubsection{PruneTreeCommand}
			Módulo físico que implementa el comando de interfaz de usuario que brinda la posibilidad de ordenar la poda del árbol de testing. Esto permite que el programa intente eliminar clases vacías. Oculta algoritmos y estructuras de datos necesarios para lograr su propósito.
			\subsubsection{RefineOpCommand}
			Módulo físico que implementa el comando de interfaz de usuario que permite refinar casos abstractos de prueba. Recibe como parametros el nombre de una operacion o de una clase en particular, el nombre de la unidad que se esta testeando, el lenguaje al cual se refinará y el nombre de la ley de refinamiento. En caso de que se reciba el nombre de una operacion se solicita el refinamiento de todas las hojas de dicha operacion. En caso de que se reciba el nombre de una clase de prueba, se solicita el refinamiento de la clase en cuestión. Oculta algoritmos y estructuras de datos necesarios para lograr su propósito.
			\subsubsection{ResetCommand}
			Módulo físico que implementa el comando de interfaz de usuario que brinda la posibilidad de remover toda la información cargada o generada por Fastest, como ser, una especificación Z, operaciones seleccionadas para ser testeadas, tácticas asociadas a una operación a ser testeadas, un árbol de prueba generado, etc. Oculta algoritmos y estructuras de datos necesarios para lograr su propósito.
			\subsubsection{SearchTheoremsCommand}
			Módulo físico que implementa el comando de interfaz de usuario que brinda la funcionalidad de buscar, para una clase de prueba, las posibles combinaciones de las expresiones contenidas en sus predicados que se ajustan a la firma de los teoremas de eliminación. Esto permite determinar cuáles son los teoremas de eliminación candidatos para aplicar a la clase de prueba. Oculta algoritmos y estructuras de datos necesarios para lograr su propósito.
			\subsubsection{SelOpCommand}
			Módulo físico que implementa el comando de interfaz de usuario que permite seleccionar una operación a testear junto con la estrategia de aplicación de tácticas que le corresponde. Oculta algoritmos y estructuras de datos necesarios para lograr su propósito.
			\subsubsection{SelPredCommand}
			Módulo físico que implementa el comando de interfaz de usuario que permite seleccionar un esquema como predicado. Oculta algoritmos y estructuras de datos necesarios para lograr su propósito.
			\subsubsection{SetAxDefCommand}
			Módulo físico que implementa el comando de interfaz de usuario que permite establecer valores para las variables dadas en las definiciones axiomáticas. Se valida que el valor ingresado tenga el tipo adecuado respecto a las definiciones axiomáticas y que también se veriquen sus predicados. Además no podrá darse el valor para una variable que aparezca en el predicado de una clase de prueba previamente podada. SetAxDefCommand oculta algoritmos y estructuras de datos necesarias para lograr su propósito.
			\subsubsection{SetFiniteModelsCommand}
			Módulo físico que implementa el comando de interfaz de usuario que permite establecer la estrategia de generación de casos de prueba que será utilizada con la clase de prueba especificada. En particular se determinarán los modelos finitos a considerarse en el cálculo de casos de prueba. SetFiniteModelsCommand oculta algoritmos y estructuras de datos necesarias para lograr su propósito.
			\subsubsection{ShowAxDefCommand}
			Módulo físico que implementa el comando de interfaz de usuario que permite mostrar en pantalla las definiciones axiomáticas que hayan sido cargadas con una especificación. Oculta algoritmos y estructuras de datos necesarios para lograr su propósito.
			\subsubsection{ShowAxDefValuesCommand}
			Módulo físico que implementa el comando de interfaz de usuario que permite mostrar en pantalla los valores asignados a las variables definidas en las definiciones axiomáticas que hayan sido cargadas con una especificación. Estos valores pueden estar dados en los predicados de las definiciones o haber sido ingresados por el usuario. Oculta algoritmos y estructuras de datos necesarios para lograr su propósito.
			\subsubsection{ShowConcreteTCaseCommand}
			Módulo físico que implementa el comando de interfaz de usuario que brinda la funcionalidad de presentar ante el usuario los casos refinados. Se pueden mostrar todos los casos refinados en la actual sesion de Fastest, los casos relacionados con una operacion en particular o un caso en especial. De acuerdo a la opcion que se setee los resultados se mostraran por pantalla o se alamacenaran en un archivo.Oculta algoritmos y estructuras de datos necesarios para lograr su propósito.
			\subsubsection{ShowHelpCommand}
			Módulo físico que implementa el comando de interfaz de usuario que brinda la funcionalidad de presentación de la ayuda de Fastest. Oculta algoritmos y estructuras de datos necesarios para lograr su propósito.
			\subsubsection{ShowLoadedOpsCommand}
			Módulo físico que implementa el comando de interfaz de usuario que que permite presentar en pantalla los nombres de las operaciones cargadas con la especificación actual. Oculta algoritmos y estructuras de datos necesarios para lograr su propósito.
			\subsubsection{ShowSchCommand}
			Módulo físico que implementa el comando de interfaz de usuario que permite presentar los esquemas que estén en el contexto de la herramienta. Esto es, mostrar esquemas de operación y clases y casos de prueba, en su totalidad, por operación o individualmente. La impresión puede hacerse en pantalla o sobre algún archivo especificado, con la posibilidad de crear un archivo en formato Latex que posteriormente puede ser compilado. Oculta algoritmos y estructuras de datos necesarios para lograr su propósito.
			\subsubsection{ShowSelOpsCommand}
			Módulo físico que implementa el comando de interfaz de usuario que brinda la funcionalidad de presentación de los nombres de las operaciones seleccionadas para ser testeadas. Junto con el nombre, se imprime la estrategia de aplicación de tácticas y la lista de tácticas que le corresponde a cada una. ShowSelOpsCommand oculta algoritmos y estructuras de datos necesarios para lograr su propósito.
			\subsubsection{ShowSelPredsCommand}
			Módulo físico que implementa el comando de interfaz de usuario que brinda la funcionalidad de presentación de los nombres de los esquemas seleccionados como predicados. ShowSelPredsCommand oculta algoritmos y estructuras de datos necesarios para lograr su propósito.			
			\subsubsection{ShowSpecCommand}
			Módulo físico que implementa el comando de interfaz de usuario que permite presentar la especificación cargada en el contexto de la herramienta, tanto en su forma original como con sus esquemas expandidos. La impresión puede hacerse en pantalla o sobre algún archivo especificado, con la posibilidad de crear un archivo en formato Latex, que posteriormente puede ser compilado. Oculta algoritmos y estructuras de datos necesarios para lograr su propósito.
			\subsubsection{ShowTacicsCommand}
			Módulo físico que implementa el comando de interfaz de usuario que brinda la funcionalidad de presentación de las distintas tácticas de testing disponibles en la herramienta. Oculta algoritmos y estructuras de datos necesarios para lograr su propósito.
			\subsubsection{ShowTTCommand}
			Módulo físico que implementa el comando de interfaz de usuario que brinda la posibilidad de presentar un árbol de prueba generado para determinada operación, o si se desea, de todos los árboles de prueba que hayan sido generados. La impresión puede hacerse en pantalla o sobre algún archivo especificado, con la posibilidad de crear un archivo latex que posteriormente puede ser compilado. ShowTTCommand oculta algoritmos y estructuras de datos necesarios para lograr su propósito.
			\subsubsection{ShowVersionCommand}
			Módulo físico que implementa el comando de interfaz de usuario que brinda la funcionalidad de presentación de la versión actual del Fastest. Oculta algoritmos y estructuras de datos necesarios para lograr su propósito.
			\subsubsection{UnPruneCommand}
			Módulo físico que implementa el comando de interfaz de usuario que brinda la posibilidad de quitar la marca de poda de una clase de prueba en un árbol de prueba. Esto permite revertir la poda de una clase, que pudo ordenarse incorrectamente. UnPruneCommand oculta algoritmos y estructuras de datos necesarios para lograr su propósito.
			\subsubsection{UnSelAllOpsCommand}
			Módulo físico que implementa el comando de interfaz de usuario que brinda la funcionalidad de quitar todas las operaciones de la lista de operaciones a testear. Oculta algoritmos y estructuras de datos necesarios para lograr su propósito.
			\subsubsection{UnSelAllPredsCommand}
			Módulo físico que implementa el comando de interfaz de usuario que brinda la funcionalidad de quitar la selección de todos los esquemas seleccionados como predicados. Oculta algoritmos y estructuras de datos necesarios para lograr su propósito.
			\subsubsection{UnSelOpCommand}
			Módulo físico que implementa el comando de interfaz de usuario que brinda la funcionalidad de quitar una operación de la lista de operaciones a testear. Oculta algoritmos y estructuras de datos necesarios para lograr su propósito.
			\subsubsection{UnSelPredCommand}
			Módulo físico que implementa el comando de interfaz de usuario que brinda la funcionalidad de quitar la selección de un esquema seleccionado como predicado. Oculta algoritmos y estructuras de datos necesarios para lograr su propósito.
		\subsection{TCaseStrategyParsers}
		Módulo lógico que agrupa a aquellos módulos que realizan algún parseo de la entrada del usuario al momento que este elige la estrategia de generación de casos de prueba.
			\subsubsection{CompleteTCaseStrategyParser}
			Módulo físico que brinda la funcionalidad de parseo de los parámetros que el usuario del sistema pasa al elegir la estrategia completa de generación de casos de prueba. El módulo oculta el algoritmo que implementa la mencionada tarea.
			\subsubsection{GivenIntFiniteModelParser}
			Módulo físico que brinda la funcionalidad de parseo de los parámetros que el usuario del sistema pasa al elegir la estrategia iterativa de generación de casos de prueba que en particular genera los modelos finitos para los enteros utilizando los valores que aparecen en la clase de prueba para la que se quiere encontrar un caso de prueba. GivenIntFiniteModelParser oculta el algoritmo que implementa la mencionada tarea.
			\subsubsection{GivenNatFiniteModelParser}
			Módulo físico que brinda la funcionalidad de parseo de los parámetros que el usuario del sistema pasa al elegir la estrategia iterativa de generación de casos de prueba que en particular genera los modelos finitos para los naturales utilizando los valores que aparecen en la clase de prueba para la que se quiere encontrar un caso de prueba. GivenNatFiniteModelParser oculta el algoritmo que implementa la mencionada tarea.
			\subsubsection{IntFiniteModelParser}
			Interfaz que abstrae el parseo de los parámetros que el usuario del sistema pasa al seleccionar la estrategia iterativa de generación de casos de prueba junto con determinada estrategia para generar los modelos finitos para el tipo de los enteros. Debe crearse un heredero de este módulo cada vez que se agrega una nueva estrategia al sistema.
			\subsubsection{IterativeTCaseStrategyParser}
			Módulo físico que brinda la funcionalidad de parseo de los parámetros que el usuario del sistema pasa al elegir la estrategia iterativa de generación de casos de prueba. El módulo oculta el algoritmo que implementa la mencionada tarea.
			\subsubsection{NatFiniteModelParser}
			Interfaz que abstrae el parseo de los parámetros que el usuario del sistema pasa al seleccionar la estrategia iterativa de generación de casos de prueba junto con determinada estrategia para generar los modelos finitos para el tipo de los enteros. Debe crearse un heredero de este módulo cada vez que se agrega una nueva estrategia al sistema.
			\subsubsection{SeedsIntFiniteModelParser}
			Módulo físico que brinda la funcionalidad de parseo de los parámetros que el usuario del sistema pasa al elegir la estrategia iterativa de generación de casos de prueba que en particular genera los modelos finitos para los enteros utilizando los valores que aparecen en la clase de prueba para la que se quiere encontrar un caso de prueba, y que además les agrega valores intermedios entre estos. SeedsIntFiniteModelParser oculta el algoritmo que implementa la mencionada tarea.
			\subsubsection{SeedsNatFiniteModelParser}
			Módulo físico que brinda la funcionalidad de parseo de los parámetros que el usuario del sistema pasa al elegir la estrategia iterativa de generación de casos de prueba que en particular genera los modelos finitos para los naturales utilizando los valores que aparecen en la clase de prueba para la que se quiere encontrar un caso de prueba, y que además les agrega valores intermedios entre estos. SeedsNatFiniteModelParser oculta el algoritmo que implementa la mencionada tarea.
			\subsubsection{TCaseStrategyParser}
			Interfaz que abstrae el parseo de los parámetros que el usuario del sistema pasa al seleccionar determinada estrategia de generación de casos de prueba. Debe crearse un heredero de este módulo cada vez que se agrega una nueva estrategia al sistema.
			\subsubsection{ZeroIntvParser}
			Módulo físico que brinda la funcionalidad de parseo de los parámetros que el usuario del sistema pasa al elegir la estrategia iterativa de generación de casos de prueba que en particular genera los modelos finitos para los enteros utilizando los valores que rodean al 0 en una cantidad solicitada. ZeroIntFiniteModelParser oculta el algoritmo que implementa la mencionada tarea.
			\subsubsection{ZeroNatFiniteModelParser}
			Módulo físico que brinda la funcionalidad de parseo de los parámetros que el usuario del sistema pasa al elegir la estrategia iterativa de generación de casos de prueba que en particular genera los modelos finitos para los naturales utilizando los valores mayores al 0 en una cantidad solicitada. ZeroNatFiniteModelParser oculta el algoritmo que implementa la mencionada tarea.
		\subsection{ClientGUI}
		Módulo físico encargado de implementar la interfaz gráfica de usuario. Oculta algoritmos y estructuras de datos necesarios para lograr su propósito. Este módulo es heredero de ClientUI, dado que la interfaz gráfica es una interfaz de usuario particular.
		\subsection{ClientTextUI}
		Módulo físico encargado de implementar la interfaz de usuario en modo texto. Oculta algoritmos y estructuras de datos necesarios para lograr su propósito. Este módulo es heredero de ClientUI, dado que la interfaz en modo texto es una interfaz de usuario particular.
		\subsection{ClientUI}
		Módulo físico encargado de brindar la funcionalidad general de las interfaces de usuario. Oculta algoritmos y estructuras de datos necesarios para lograr su propósito.
	\section{Util}
	Módulo lógico que agrupa aquellos módulos que brindan alguna funcionalidad general que es de utilidad para el sistema.
		\subsection{AbstractOrder}		
		Interfaz cuya responsabilidad es dar la funcionalidad correspondiente a una orden, es decir, una unidad de cómputo donde se indica la petición de una llamada a procedimiento y el receptor de la llamada. El módulo fue concebido en base al patrón de diseño Command.








%% EMPIEZA COMMON







\chapter{Common}
Este módulo lógico incluye los módulos que representan elementos de software comunes a las aplicaciones Cliente y Servidor de Cómputo. El mismo se divide en los siguientes módulos lógicos.
	\section{RepositoryModules}
	Es el módulo lógico que agrupa módulos relacionados con repositorios abstractos de objetos y con iteradores que pueden definirse sobre estos repositorios.
		\subsection{AbstractIterator}
		Módulo físico que brinda la funcionalidad correspondiente a un iterador sobre agregados de elementos. Este módulo no se implementa, solo brinda una interfaz para los módulos que heredan de él. Es un módulo genérico cuyo parámetro formal corresponde al tipo de los elementos sobre los que se puede iterar.
		\subsection{AbstractRepository}
		Módulo físico que brinda la funcionalidad correspondiente a un agregado o repositorio abstracto de elementos. Este módulo no se implementa, solo brinda una interfaz para los módulos que heredan de él. Es un módulo genérico cuyo parámetro formal corresponde al tipo de los elementos que pueden almacenarse en el repositorio.
		\subsection{ConcreteRepository}
		Hereda del módulo AbstractRepository ya que resulta ser una implementación particular de él. Oculta las estructuras de datos y los algoritmos que cumplen con la interfaz dada por AbstractRepository. Al heredar de un módulo genérico este módulo resulta ser también genérico.
	\section{ZAbstraction}
	Es un módulo lógico que incluye módulos ligados a construcciones del lenguaje de especificaciones Z.
		\subsection{CZT}
		Aquí se agrupan los distintos módulos relacionados con el proyecto CZT (Community Z Tools) y que son los que implementan las distintas construcciones del lenguaje de especificaciones Z, un parser de expresiones Z dadas en formato Latex, y un evaluador de predicados y expresiones Z.
			\subsubsection{CZTVisitors}
			Módulo lógico que agrupa aquellos módulos que permiten visitar construcciones en lenguaje Z aplicando cierta operación.
				\paragraph{AndOrPredDistributor}
				Módulo físico basado en el patrón de diseño Visitor que permite aplicar a predicados la propiedad distributiva de la conjunción respecto a la disyunción. El módulo oculta los algoritmos que implementan dicha tarea.
				\paragraph{AndPredClausesExtractor}
				Módulo físico basado en el patrón de diseño Visitor que permite obtener, de una conjunción de predicados, el repositorio con los predicados que la conforman. El módulo oculta los algoritmos que implementan dicha tarea.
				\paragraph{AndPredClausesRemover}
				Módulo físico basado en el patrón de diseño Visitor que permite remover de un predicado que sea una conjunción, todas las clausulas iguales a cierto predicado p. p es un predicado que se toma como argumento en el constructor del módulo. El módulo oculta los algoritmos y estructuras de datos que implementan dicha tarea.
				\paragraph{AndPredSimplifier}
				Módulo físico basado en el patrón de diseño Visitor que permite simplificar predicados aplicando las reglas de simplificación de idempotencia y de absorción de la conjunción. El módulo oculta los algoritmos que implementan dicha tarea.
				\paragraph{AuxDeclGenerator}
				Módulo físico basado en el patrón de diseño Visitor que permite construir recursivamente esquemas auxiliares que contengan declaraciones de variables de entrada o de estado sin primar y no tengan predicados. Estos esquemas auxiliares se pueden reemplazar por los originales cuando quiera hacerse referencia solamente a las declaraciones de variables de entrada. El módulo oculta los algoritmos que implementan dicha tarea.
				\paragraph{ContainsTermInPredVerifier}
				Módulo físico basado en el patrón de diseño Visitor que permite verificar si un término Z dado está contenido en el predicado de un esquema, pudiendo a su vez este esquema tener incluidos otros esquemas. El módulo oculta los algoritmos que implementan dicha tarea.				
				\paragraph{ContainsTermVerifier}
				Módulo físico basado en el patrón de diseño Visitor que permite verificar si un término del lenguaje Z contiene a otro. El módulo oculta los algoritmos que implementan dicha tarea.
				\paragraph{ContainsVarDeclVerifier}
				Módulo físico basado en el patrón de diseño Visitor que permite verificar si una variable está declarada en un esquema, pudiendo estar este esquema incluyendo otros esquemas. El módulo oculta los algoritmos que implementan dicha tarea.				
				\paragraph{CZTCloner}
				Módulo físico basado en el patrón de diseño Visitor que permite realizar la clonación (en términos de programación Java) de objetos de las diferentes clases definidas por CZT. El módulo oculta los algormitmos que implementan tal funcionalidad.
				\paragraph{CZTReplacer}
				Módulo físico basado en el patrón de diseño Visitor que permite reemplazar un término Z por otro en el contexto del término Z al que se aplica el visitante. El término original y el que reemplazará al original se deben pasar como parámetros al constructor del módulo. CZTReplacer oculta estructuras de datos y algoritmos que implementan la tarea mencionada.
				\paragraph{DeclsExtractor}
				Módulo físico basado en el patrón de diseño Visitor que permite calcular la lista de declaraciones del Valid Input Space (VIS) para una operación.  Este módulo calcula la lista de declaraciones del VIS expandiendo solamente los esquemas que no estén seleccionados como operaciones ni como predicados. DeclsExtractor oculta estructuras de datos y algoritmos que implementan la tarea mencionada.				
				\paragraph{DNFPredExtractor}
				Módulo físico basado en el patrón de diseño Visitor que permite calcular el predicado del Valid Input Space (VIS) para una operación. Este predicado lo calcula en forma de lista de predicados en DNF, con esta lista representando la conjunción de los predicados que la componen. Este módulo calcula la lista de predicados en DNF del VIS expandiendo solamente los esquemas que no estén seleccionados como operaciones ni como predicados. DNFPredExtractor oculta estructuras de datos y algoritmos que implementan la tarea mencionada.				
				\paragraph{ImpliesPredRemover}
				Módulo físico basado en el patrón de diseño Visitor que permite transformar todas los predicados de la forma $a \Rightarrow b$ en predicados de la forma $\lnot a \lor b$. El módulo oculta los algoritmos que implementan dicha tarea.
				\paragraph{NegPredDistributor}
				Módulo físico basado en el patrón de diseño Visitor que permite aplicar a predicados las Leyes de Morgan y la eliminación de la doble negación. El módulo oculta los algoritmos que implementan dicha tarea.
				\paragraph{OpNamesExtractor}
				Módulo físico basado en el patrón de diseño Visitor que permite recorrer una especificación y extrayendo en una lista los nombres de los esquemas que son esquemas de operación.  El módulo oculta los algoritmos que implementan dicha tarea.			
				\paragraph{OrPredRemover}
				Módulo físico basado en el patrón de diseño Visitor que permite remover de un predicado que sea una conjunción, todas las clausulas que sean disyunciones tales que alguno de los operandos que las conforman sea igual a cierto predicado p que se toma como argumento en el constructor del módulo. El módulo oculta los algoritmos que implementan dicha tarea.
				\paragraph{OutputAtomicPredsRemover}
				Módulo físico basado en el patrón de diseño Visitor que permite tomar un predicado en DNF y remover de él los predicados atómicos que contengan variables primadas o de salida. El módulo oculta los algoritmos que implementan dicha tarea.			
				\paragraph{ParamExtractor}
				Módulo físico basado en el patrón de diseño Visitor que permite, dado un término del lenguaje Z, obtener una lista con sus parámetros. Por ejemplo, al término $a = b$ lo conforman $a$ y $b$.El módulo oculta los algoritmos que implementan dicha tarea.
				\paragraph{PredInOrVerifier}
				Módulo físico basado en el patrón de diseño Visitor que permite determinar si el predicado al que se le aplica el visitante es una disyunción donde uno de sus operandos es el predicado que se pasa al constructor del módulo. El módulo oculta los algoritmos que implementan dicha tarea.
				\paragraph{PredRemover}
				Módulo físico basado en el patrón de diseño Visitor que permite remover de un predicado, que esté en forma normal disyuntiva, todos los literales (o negaciones de literales) que contengan la ocurrencia de alguno de los nombres de variables contenidos en la instancia de VarNameRepository que el visitante toma como parámetro. El módulo oculta los algoritmos y estructuras de datos que implementan dicha tarea.
				\paragraph{PredSchemaUnfolder}
				Módulo físico basado en el patrón de diseño Visitor que permite expandir los referencias a esquemas que aparezcan en un predicado, por los predicados de los esquemas referenciados, siempre y cuando estos esquemas no estén seleccionado como operaciones o como predicados. El módulo oculta los algoritmos y estructuras de datos que implementan dicha tarea.			
				\paragraph{PrimeVarsMaker}
				Módulo físico basado en el patrón de diseño Visitor que permite primar todas las variables (es decir, concatenarles el caracter $'$) en la expresión o esquema Z visitado. El módulo oculta los algoritmos que implementan dicha tarea.
				\paragraph{DeleteParenAnn}
				Módulo físico basado en el patrón de diseño Visitor que permite borrar todas las anotaciones referentes a paréntesis que almacena un término. El módulo oculta los algoritmos que implementan dicha tarea.
				\paragraph{ExpressionsExtractor}
				Módulo físico basado en el patrón de diseño Visitor que permite extraer todas las expresiones bien formadas que integran un AST. El módulo oculta los algoritmos que implementan dicha tarea.
				\paragraph{FuncApplExtractor}
				Módulo físico basado en el patrón de diseño Visitor que permite extraer los operandos en una aplicación de función. El módulo oculta los algoritmos que implementan dicha tarea.
				\paragraph{MemPredExtractor}
				Módulo físico basado en el patrón de diseño Visitor que permite extraer los operandos en una aplicación de un operador de relación. El módulo oculta los algoritmos que implementan dicha tarea.
				\paragraph{RefExprToArithmos}
				Módulo físico basado en el patrón de diseño Visitor que permite reemplazar las referencias a cualquier objeto por referencias a números naturales. El módulo oculta los algoritmos que implementan dicha tarea.
				\paragraph{StringToNumReplacer}
				Módulo físico basado en el patrón de diseño Visitor que permite reemplazar en una expresión todas ocurrencias de constantes alfanuméricas por ocurrencias de constantes numéricas. Esto se lleva a cabo de manera tal que todas las ocurrencias de una misma constante alfanumérica se reemplazan por la misma constante numérica y que dos ocurrencias de constantes alfanuméricas diferentes se reemplazan por constantes numéricas diferentes. Esto significa que a medida que se recorre la expresión se va construyendo una función inyectiva entre constantes alfanuméricas y constantes numéricas. Esta función debe almacenarse como miembro de la instancia de StringToNumReplacer. El módulo oculta los algoritmos y estructuras de datos que implementan dicha tarea.
				\paragraph{WordsFinder}
				Módulo físico basado en el patrón de diseño Visitor que permite determinar si alguna de las variables contenidas en el repositorio de nombres de variables que se pasa como argumento al constructor de instancias de este módulo ocurre en la expresión o esquema Z visitado. El módulo oculta los algoritmos que implementan dicha tarea.
			\subsubsection{UniqueZLive}
			Módulo físico que encapsula una instancia del módulo ZLive (de CZT) con el objeto de que pueda accederse a ella como si fuera la única existente en el sistema.
		\subsection{AbstractOutput}
		Interfaz que abstrae la salida concreta (a nivel de especificación) que surge de ejecutar un caso de prueba. Este módulo hereda del módulo OutputClass. Esto se decidió en base a que cada salida abstracta es una clase de salida Z con la condición adicional de que su predicado debe estar compuesto por la conjunción de cero o más predicados de la forma variable=expresión.
		\subsection{AbstractOutputImpl}
		Módulo físico que implementa la interfaz AbstractOutput.
		\subsection{AbstractTCase}
		Módulo físico que oculta la estructura de datos y los algoritmos que implementan una clase de prueba del lenguaje Z. Este módulo hereda del módulo TClass. Esto se decidió en base a que cada caso de prueba Z es una clase de prueba Z con la restricción adicional de tener a su predicado compuesto por la conjunción de cero o más predicados de la forma variable=expresión. 
		\subsection{AxDef}
		Interfaz que abstrae una definición axiomática del lenguaje Z. Este módulo hereda de AxPara (módulo del subsistema CZT) ya que cada instancia del módulo AxDef puede pensarse como una instancia de AxPara con una restricción sobre su contenido.
		\subsection{AxDefImpl}
		Módulo físico que implementa la interfaz AxDef.
		\subsection{AxParaRepository}
		Módulo físico que oculta la estructura de datos y los algoritmos que implementan un agregado o repositorio de instancias de AxPara
		\subsection{HorizDef}
		Interfaz que abstrae una definición horizontal del lenguaje Z. Este módulo hereda de AxPara (módulo del subsistema CZT) ya que cada instancia del módulo HorizDef es, en términos semánticos, una instancia de AxPara con una restricción sobre su contenido.
		\subsection{HorizDefImpl}
		Módulo físico que implementa la interfaz HorizDef.
		\subsection{OpNameRepository}
		Módulo físico que oculta la estructura de datos y los algoritmos que implementan un agregado o repositorio de instancias de OpName.
		\subsection{OpScheme}
		Interfaz que abstrae un esquema de operación del lenguaje Z. Este módulo hereda del módulo Scheme. Esto se decidió en base a que cada esquema de operación Z es un esquema Z con la condición de tener variables de entrada y salida o variables no primadas y primadas.
		\subsection{OpSchemeImpl}
		Módulo físico que implementa la interfaz OpScheme.
		\subsection{OutputClass}
		Interfaz que abstrae una clase de salida del lenguaje Z. Este módulo hereda del módulo Scheme. Esto se decidió en base a que cada clase de salida Z es un esquema Z con la restricción adicional de no tener variables de entrada, de salida ni no primadas.
		\subsection{OutputClassImpl}
		Módulo físico que implementa la interfaz OutputClass.
		\subsection{OutputClassRepository}
		Módulo físico que oculta la estructura de datos y los algoritmos que implementan un agregado o repositorio de instancias de OutputClass.
		\subsection{Scheme}
		Interfaz que abstrae un esquema del lenguaje Z. Este módulo hereda de AxPara (módulo del subsistema CZT) ya que cada instancia del módulo Scheme es, en términos semánticos, una instancia de AxPara con una restricción adicional sobre su contenido.
		\subsection{SchemeImpl}
		Módulo físico que implementa la interfaz Scheme.
		\subsection{SchemeUnfolder}
		Módulo físico cuyo funcionalidad consiste en realizar la expansión de esquemas de una especificación Z. Oculta la estructura de datos y los algoritmos que implementan tal tarea.
		\subsection{SchName}
		Módulo físico que representa el nombre de un esquema. Se usa por comodidad en la descripción del sistema y no se implementa.
		\subsection{SpecUtils}
		Módulo físico que brinda funcionalidades útiles en el manejo de especificaciones Z, como ser funciones que calculan el Valid Input Space (VIS) de una operación o que partiendo de una especificación y un nombre de operación obtienen el correspondiente esquema de operación . El módulo oculta los algoritmos que implementan tales tareas.
		\subsection{TClass}
		Interfaz que abstrae una clase de prueba del lenguaje Z. Este módulo hereda del módulo Scheme. Esto se decidió en base a que cada clase de prueba Z es un esquema Z con la restricción no tener variables de entrada, de salida ni primadas.
		\subsection{TClassImpl}
		Módulo físico que implementa la interfaz TClass.
		\subsection{TClassRepository}
		Módulo físico que oculta la estructura de datos y los algoritmos que implementan un agregado o repositorio de instancias de TClass.
		\subsection{UtilSymbols}
		Módulo físico que oculta la estructura de datos y los algoritmos que implementan algunos símbolos comunes del lenguaje de especificaciones Z y que se utilizan frecuentemente en el código de la herramienta. Por ejemplo, se puede obtener el símbolo para los números naturales, el de los enteros, el de las flechas que correspondan a distintos tipos de funciones, etc.
		\subsection{VarName}
		Módulo físico que representa el nombre de una variable. Se usa por comodidad en la descripción del sistema y no se implementa.
		\subsection{VarNameRepository}
		Módulo físico que oculta la estructura de datos y los algoritmos que implementan un agregado o repositorio de instancias de VarName.
		\subsection{VISGen}
		Módulo físico que permite calcular el VIS (Valid Input Space) de un esquema de operación Z. Lo calcula teniendo en cuenta y no expandiendo los esquemas seleccionados como operaciones y los esquemas seleccionados como predicados. Oculta los algoritmos que implementan tal tarea.
	\section{OpName}
	Módulo físico que representa el nombre de una operación. Se usa por comodidad en la descripción del sistema y no se implementa.
	\section{Regex}
	Módulo lógico que nuclea a los módulos que brindan funcionalidades que involucran expresiones regulares.
		\subsection{RegExUtils}
		Módulo físico que brinda funcionalidades generales relativas a las expresiones regulares. Permite el agregados de caracteres de escape a una cadena de caracteres así como también la construcción de ciertas expresiones.
		Oculta los algoritmos empleados.
	\section{Util}
	Módulo lógico que agrupa módulos que brindan funcionalidades generales a la aplicación.
		\subsection{MathUtils}
		Módulo físico que brinda funcionalidades relativas a operaciones matemáticas, tales como el cálculo de permutaciones y conjuntos de partes de conjuntos.
		Oculta los algoritmos empleados.


%% EMPIEZA COMPSERVER







\chapter{CompServer}
Módulo lógico que agrupa la funcionalidad y los datos correspondientes a la aplicación Servidor de Cómputo del sistema Fastest. Se decidió dividir al módulo separando unidades de cómputo que ofrecen servicios de cálculo de casos de prueba de aquellas que verifican la correspondencia de casos de prueba con la salida que resulta de ejecutarlos, de aquellas que se encargan de podar el árbol de testing y de aquellas que tienen que ver con el manejo de solicitudes de servicios de aplicaciones Cliente.
	\section{ServerTCaseChecking}
	Módulo lógico que contiene módulos que implementan la verificación de correspondencias entre casos de pruebas abstractas con las salidas abstracta que les corresponden. 
		\subsection{TCaseChecker}
		Módulo físico que provee funcionalidad para comprobar si cierto caso de prueba abstracto produce el resultado esperado en relación a una especificación dada. Oculta implementación de algoritmos.
	\section{ServerTCaseGeneration}
	Módulo lógico que agrupa a aquellos módulos encargados de implementar la generación de casos de prueba abstractos. Se divide en módulos de acuerdo a si tienen relación con modelos finitos, con la generación de casos de prueba propiamente dicha, o con la evaluación de predicados de esquemas Z.
		\subsection{Evaluation}
		Módulo lógico que contiene aquellos módulos relacionados con la evaluación de predicados de esquemas del lenguaje Z.
			\subsubsection{EvaluationResp}
			Módulo físico que representa un par de elementos (r,l), donde r es una instancia de Bool y l es una instancia de String. Este módulo es utilizado por SchemeEvaluator para devolver el resultado y un log de resumen de la evaluación realizada. El módulo EvaluationResp oculta las estructuras de datos y los algoritmos que implementan al par.
			\subsubsection{NormalTypeAndFM}
			Módulo físico que representa un par de elementos (t,fm), donde t es una instancia del módulo Expr y fm es una instancia del módulo SetExpr. El módulo NormalTypeAndFM oculta las estructuras de datos y los algoritmos que implementan al par.
			\subsubsection{SchemeEvaluator}
			Módulo físico que permite evaluar si el predicado de una clase de prueba es satisfecho por un conjunto dado de asignaciones de variables a expresiones. Esta evaluación se lleva a cabo utilizando el procedimiento evalSchemeSat(), que toma como parámetros la clase de prueba (instancia de TClass) y la instancia de VarExprMap que mapea nombres de variables a expresiones y devuelve una instancia de EvaluationResp con la respuesta de la evaluación y un log de resumen de la misma. El módulo SchemeEvaluator oculta las estructuras de datos y los algoritmos que implementan al par.
			\subsection{VarValueMap}
			Módulo físico cuyas instancias mapean instancias del módulo RefExpr a instancias del módulo Expr, que corresponden a nombres de variables y a valores, respectivamente. El módulo se implementa utilizando la colección Map de Java instanciada en RefExpr y en Expr.
		\subsection{FiniteModels}
		Módulo lógico que agrupa a aquellos otros que participan en la generación de modelos finitos para tipos del lenguaje Z.
			\subsubsection{IntFiniteModels}
			Módulo lógico que agrupa a aquellos otros módulos que participan en la generación de modelos finitos para el tipo de los enteros en el lenguaje Z.
				\paragraph{GivenIntFiniteModel}
				Módulo físico que oculta las estructuras de datos y los algoritmos que implementan un modelo finito, asociado al tipo el lenguaje Z que corresponde a los enteros, y que en particular construye el conjunto de valores con los de una lista dada. El módulo es heredero de IntFiniteModel ya que implementa un modelo finito para los enteros.
				\paragraph{IntFiniteModel}
				Interfaz que abstrae al modelo finito asociado al tipo del lenguaje Z que corresponde a los números enteros. 
				\paragraph{SeedsIntFiniteModel}
				Módulo físico que oculta las estructuras de datos y los algoritmos que implementan un modelo finito, asociado al tipo del lenguaje Z que corresponde a los enteros, y que en particular construye el conjunto de valores con los de una lista dada y agregando valores intermedios entre cada par consecutivo de estos. El módulo es heredero de IntFiniteModel ya que implementa un modelo finito para los enteros.
				\paragraph{ZeroIntFiniteModel}
				Módulo físico que oculta las estructuras de datos y los algoritmos que implementan un modelo finito, asociado al tipo del lenguaje Z que corresponde a los enteros, y que en particular considera una cantidad indicada de valores que rodean al cero. El módulo es heredero de IntFiniteModel ya que implementa un modelo finito para los enteros.
			\subsubsection{NatFiniteModels}
			Módulo lógico que agrupa a aquellos otros módulos que participan en la generación de modelos finitos para el tipo de los naturales en el lenguaje Z.
				\paragraph{GivenNatFiniteModel}
				Módulo físico que oculta las estructuras de datos y los algoritmos que implementan un modelo finito, asociado al tipo del lenguaje Z que corresponde a los naturales, y que en particular construye el conjunto de valores con los de una lista dada. El módulo es heredero de NatFiniteModel ya que implementa un modelo finito para los naturales.
				\paragraph{NatFiniteModel}
				Interfaz que abstrae al modelo finito asociado al tipo del lenguaje Z que corresponde a los números naturales. 
				\paragraph{SeedsNatFiniteModel}
				Módulo físico que oculta las estructuras de datos y los algoritmos que implementan un modelo finito, asociado al tipo del lenguaje Z que corresponde a los naturales, y que en particular construye el conjunto de valores con los de una lista dada y agregando valores intermedios entre cada par consecutivo de estos. El módulo es heredero de NatFiniteModel ya que implementa un modelo finito para los naturales.
				\paragraph{ZeroNatFiniteModel}
				Módulo físico que oculta las estructuras de datos y los algoritmos que implementan un modelo finito asociado al tipo del lenguaje Z que corresponde a los naturales, y que en particular considera una cantidad indicada de valores que son consecutivos y mayores al cero. El módulo es heredero de NatFiniteModel ya que implementa un modelo finito para los naturales.
			\subsubsection{FiniteModel}
			Interfaz que abstrae la estructura de datos y algoritmos que implementan un modelo finito. Un modelo finito es una estructura que se asocia a un tipo particular del lenguaje Z y, haciendo las veces de un iterador, puede solicitarsele, de a uno, los distintos elementos que conforman un subconjunto finito del tipo asociado. Este módulo se utiliza en el contexto de la estrategia IterativeTCaseStrategy, y como ésta sugiere, las instancias de FiniteModel no ocultan en su estado el modelo finito completo del tipo asociado, sino que sólo mantienen la mínima información necesaria para saber qué elemento del modelo debe devolverse la próxima vez que se solicite uno.
			Tiene que haber un módulo heredero de FiniteModel por cada tipo diferente del lenguaje Z.
			\subsubsection{FiniteModelCreator}
			Módulo físico basado en el patrón de diseño Visitor que permite recorrer una especificación de forma tal de ir creando, y agregando a una estructura que forma parte del estado del módulo, modelos finitos (instancias que heredan de FiniteModel), uno por cada tipo que se defina globalmente en la especificación.
			\subsubsection{FreetypeFiniteModel}
			Módulo físico que oculta las estructuras de datos y los algoritmos que implementan un modelo finito asociado a un tipo libre de datos del lenguaje Z. El módulo es heredero de FiniteModel ya que implementa modelo finito particular.
			\subsubsection{FromToFiniteModel}
			Módulo físico que oculta las estructuras de datos y los algoritmos que implementan un modelo finito asociado al tipo del lenguaje Z que corresponde a un rango de valores y que se indica de la forma '$a \upto b$'. El módulo es heredero de FiniteModel ya que implementa un modelo finito particular.
			\subsubsection{GivenFiniteModel}
			Módulo físico que oculta las estructuras de datos y los algoritmos que implementan un modelo finito asociado a un tipo básico de datos del lenguaje Z. El módulo es heredero de FiniteModel ya que implementa un modelo finito particular.
			\subsubsection{PFuncFiniteModel}
			Módulo físico que oculta las estructuras de datos y los algoritmos que implementan un modelo finito asociado al tipo de las funciones parciales del lenguaje Z. El módulo es heredero de FiniteModel ya que implementa un modelo finito particular.
			\subsubsection{PowerFiniteModel}
			Módulo físico que oculta las estructuras de datos y los algoritmos que implementan un modelo finito asociado al tipo potencia del lenguaje Z. El módulo es heredero de FiniteModel ya que implementa un modelo finito particular.
			\subsubsection{ProdFiniteModel}
			Módulo físico que oculta las estructuras de datos y los algoritmos que implementan un modelo finito asociado al tipo producto cartesiano del lenguaje Z. El módulo es heredero de FiniteModel ya que implementa un modelo finito particular.
			\subsubsection{RelFiniteModel}
			Módulo físico que oculta las estructuras de datos y los algoritmos que implementan un modelo finito asociado al tipo de las relaciones del lenguaje Z. El módulo es heredero de FiniteModel ya que implementa un modelo finito particular.
			\subsubsection{SeqFiniteModel}
			Módulo físico que oculta las estructuras de datos y los algoritmos que implementan un modelo finito asociado al tipo de las secuencias del lenguaje Z. El módulo es heredero de FiniteModel ya que implementa un modelo finito particular.
			\subsubsection{SetFiniteModel}
			Módulo físico que oculta las estructuras de datos y los algoritmos que implementan un modelo finito asociado al tipo de los conjuntos enumerados del lenguaje Z. El módulo es heredero de FiniteModel ya que implementa un modelo finito particular.
			\subsubsection{TClassFiniteModel}
			Módulo físico que oculta las estructuras de datos y los algoritmos que implementan un modelo finito asociado a una clase de prueba para la cual se quiere obtener un caso de prueba. TClassFiniteModel permite ir obteniendo, una a una, las distintas asignaciones de valores a variables de la clase de prueba asociada. Para obtener estos valores, el módulo utiliza los modelos finitos que están asociados a los tipos de las variables, solicitando valores a cada uno, según corresponda, para obtener una nueva asignación. Para evitar confusiones, vale la pena aclarar que éste módulo no hereda de FiniteModel.
			\subsubsection{TFuncFiniteModel}
			Módulo físico que oculta las estructuras de datos y los algoritmos que implementan un modelo finito asociado al tipo de los conjuntos del lenguaje Z. El módulo es heredero de FiniteModel ya que implementa un modelo finito particular.
			\subsection{TypeFiniteModelMap}
			Módulo físico cuyas instancias mapean instancias del módulo Expr a instancias del módulo FiniteModel, que corresponden a nombres de tipos de variables y a modelos finitos, respectivamente. El módulo se implementa utilizando la colección Map de Java instanciada en Expr y en FiniteModel.
			\subsection{TypeFMsMap}
			Módulo físico cuyas instancias mapean instancias del módulo Expr a instancias del módulo NormalTypeAndFM, que corresponden a nombres de tipos de variables y a pares (tipo normalizado, modelo finito), respectivamente. El módulo se implementa utilizando la colección Map de Java instanciada en Expr y en FiniteModel.
			\subsubsection{TypeFMsGenVisitor}
			Módulo físico basado en el patrón de diseño Visitor que permite obtener los modelos finitos y los tipos normalizados de todos los tipos que se definen globalmente en una especificación. Al aplicar este visitante a una especificación, la misma no resulta modificada pero se devuelve una instancia del módulo TypeFMsMap, que es la que contiene la correspondencia entre instancias de Expr, que denoten tipos, e instancias de NormalTypeAndFM, que denoten un par con el tipo normalizado (dado por una instancia de Expr) y el modelo finito del tipo (dado por una instancia de SetExpr). Por el momento, este módulo permite generar modelos finitos para tipos básicos (instancias de GivenPara), tipos libres no inductivos (instancias de Freetype) y abreviaturas que no hagan referencia a esquemas (instancias de AxPara que se correspondan a definiciones horizontales que no sean esquemas ni hagan referencia a esquemas). TypeFMsGenVisitor oculta la implementación de los algoritmos y las estructuras necesarias para llevar a cabo la tarea descripta.
		\subsection{TCaseStrategies}
		Este es un módulo lógico que contiene a aquellos módulos que representan distintas estrategias de generación de modelos finitos.
			\subsubsection{CompleteTCaseStrategy}
			Módulo físico que oculta las estructuras de datos y los algoritmos que implementan una estrategia particular de generación de casos de prueba. La estrategia consiste en primero calcular los modelos finitos de TODOS los tipos que se definen globalmente en la especificación. Luego, los de los tipos de las variables de la clase de prueba para la que se quiere encontrar un caso de prueba. Y por último, se encarga de iterar sobre las asignaciones (tomadas de los modelos finitos de los tipos) de valores a variables de la clase de prueba, hasta encontrar una que satisfaga el predicado de la clase de prueba analizada. Para hacer la evaluación de cada asignación de valores se llama al procedimiento evalSchemeSat, del módulo SchemeEvaluator. CompleteTCaseStrategy hereda del módulo TCaseStrategy, dado que implementa una estrategia particular de generación de casos de prueba.
			\subsubsection{IterativeTCaseStrategy}
			Módulo físico que oculta las estructuras de datos y los algoritmos que implementan una estrategia particular de generación de casos de prueba. La estrategia consiste en ir generando asignaciones de valores a las variables de la clase de prueba para la que se quiere obtener un caso de prueba hasta que alguna de ellas satisgafa el predicado de dicha clase de prueba. Para hacer la evaluación de cada asignación de valores se llama al procedimiento evalSchemeSat, del módulo SchemeEvaluator. A diferencia de la estrategia CompleteTCaseStrategy, IterativeTCaseStrategy no necesita generar el modelo finito completo para cada tipo de variable de la clase de prueba ni para cada tipo definido globalmente en la especificación. Si bien esta estrategia es un poco menos eficiente teniendo en cuenta el orden temporal de complejidad, desde el punto de vista espacial la mejora es notable. IterativeTCaseStrategy hereda del módulo TCaseStrategy, dado que implementa una estrategia particular de generación de casos de prueba.
			\subsubsection{ManualTCaseStrategy} 
			Módulo físico que oculta las estructuras de datos y los algoritmos que implementan una estrategia manual de generación de modelos finitos. Esto es, aquella estrategia que requiere que el usuario ingrese directamente los modelos finitos para los tipos de las variables de la clase de prueba Z analizada. Este módulo hereda de TCaseStrategy ya que representa una estrategia particular.
			\subsubsection{TCaseStrategy}
			Interfaz que abstrae las estructuras de datos y los algoritmos que implementan una estrategia de generación de casos de prueba. Este módulo está basado en el patrón de diseño Strategy. La generación de casos de prueba se hace a nivel de clase de prueba y no por operación ya que puede resultar conveniente que el encargado de testing realice alguna indicación para cada clase de prueba en función de su predicado. Es necesario definir un nuevo heredero de este módulo para agregar al sistema una nueva estrategia de generación de casos de prueba.
		\subsection{TCaseGen}
		Módulo físico que permite generar, o intentar generar, un caso de prueba abstracto dada una clase de prueba y la especificación que la contiene. Ocultas estructuras de datos y los algoritmos que implementan la tarea mencionada. 
	\section{ServerManagement}
		\subsection{ServerThread}
		Módulo físico sobre el que se atiende una solicitud de servicio particular. El procedimiento principal de este módulo es run(), en el cual se realizan solicitudes al módulo SocketReader para conocer la operación requerida así como también los parámetros necesarios para llevar a cabo la misma.Se regresa al cliente el resultado del servicio solicitado.
		\subsection{SocketReader}
		Módulo físico encargado de leer información en un flujo de entrada(en este caso un Socket) relacionada con la generación de casos de prueba. Cualquier modificación en el protocolo de comunicación Cliente/Servidor de Fastest implicará cambios en este módulo. El módulo oculta detalles del protocolo Cliente/Servidor subyacente así como también los algoritmos y estructuras de datos empleados para cumplir con su funcionalidad. 
		\subsection{ServiceManager}
		Módulo físico encargado de iniciar el funcionamiento del Servidor de Cómputo correspondiente, atendiendo pedidos de servicio de los clientes. Que se puedan atender varios servicios en simultáneo se debe a que cada uno se corre en un thread diferente, invocando al procedimiento run() del módulo ServerThread. ServiceManager oculta las estructuras de datos y los algoritmos que implementan las tareas mencionadas.
	\section{ServerPrunning}
	Módulo lógico que contiene módulos que implementan la poda del árbol de testing
		\subsection{PruneUtils}
		Módulo físico que brinda funcionalidades comunes a los módulos que intervienen en el proceso de poda. Se encarga entre otras cosas de reemplazar parámetros formales por reales, de la búsqueda de cadenas dentro del predicado de las clases, etc. El módulo oculta los algoritmos que implementan tales tareas.
		\subsection{TheoremsLoader}
		Módulo físico que se encarga de parsear el archivo de configuración que contiene la definición de los teoremas de eliminación, creando instancias de Theorem y cargándolas en la única instancia de TheoremsControl. Además tiene la responsabilidad de aplicar las reglas de reescritura sobre los predicados de los teoremas. El módulo oculta los algoritmos que implementan tales tareas. 
		\subsection{TheoremsControl}
		Módulo físico que almacena instancias de Theorem. Debe existir una única instancia por lo cual se emplea el patrón de diseño Singleton. El módulo oculta las estructuras de datos que emplea.
		\subsection{Theorem}
		Módulo físico que abstrae un teorema de eliminación. Almacena el nombre del teorema, los parámetros formales, el predicado e información relativa a los operadores especiales de Fastest.
		El módulo oculta las estructuras de datos empleadas para almacenar dicha información.
		\subsection{Variable}
		Módulo físico que abstrae una variable de un teorema de eliminación. Almacena información relativa al nombre de la variable y su tipo. El módulo oculta las estructuras de datos empleadas para almacenar dicha información.
		\subsection{PruneAnalizer}
		Módulo físico que se encarga de analizar la factibilidad de podar una clase de prueba aplicándole un teorema de eliminación y en caso afirmativo ordena la poda de dicha clase. El método principal del módulo es analize() que recibe el nombre de un teorema de eliminación, una clase de prueba y los parámetros reales. Este modulo era empleado en la primera version de la poda y en la actual ya es obsoleto.
		El módulo oculta el algoritmo que se encarga de coordinar los pasos necesarios para realizar su tarea.
		\subsection{TreePruner}
		Módulo físico que se encarga de la poda, propiamente dicha, del árbol de testing. El módulo ofrece métodos para podar una sola clase, para podar las clases descendientes de una clase en particular y para podar un árbol completo. Para este último caso interactúa con el módulo TheoremsChecker para que le obtenga una lista con los teoremas cuya expresion regular matchea con la de la clase analizada y los parámetros correspondientes y luego invoca al módulo TypeChecker para el correspondiente chequeo de tipos. 
		El módulo oculta los algoritmos empleados para cumplir con sus funcionalidades.
		\subsection{TheoremsChecker}
		Modulo fisico que se encarga de buscar teoremas cuya expresion regular matchea con el predicado de una clase que se le pasa como parametro. Devuelve el teorema con las correspondientes expresiones de la clase que matchearon.
		El módulo oculta los algoritmos empleados para cumplir con sus funcionalidades.
		\subsection{TypeChecking}
		Módulo lógico que agrupa a aquellos módulos físicos encargados de realizar el chequeo de tipos entre las expresiones contenidas en los predicados de las clases de prueba y los parámetros formales de los teoremas de eliminación.
			\subsection{ParamExaminerPred}
			Módulo físico que se encarga de extraer todas las expresiones contenidas en el predicado de una clase de prueba que recibe como parámetro, calcular las permutaciones de esos elementos y verificar cuales de esas combinaciones se adaptan a la firma de los teoremas de eliminación. Posee un método para obtener una lista con las combinaciones de expresiones que se ajustan a la firma de un teorema en particular y otro para obtener una lista con todas las combinaciones para todos los teoremas de eliminación.
			Este módulo se empleaba en la primera versión de la poda pero en la versión actual es obsoleto.
			Oculta los algoritmos y estructuras de datos que emplea para cumplir con su funcionalidad.
			\subsection{SubTyping}
			Módulo físico que se encarga de aplicar el subtipado, determinando cuando el tipo de una expresión es subtipo o no del tipo de otra expresión. Posee una variedad de métodos con diferentes firmas para adaptarse a diferentes situaciones.
			Oculta los algoritmos empleados para cumplir con su funcionalidad.
			\subsection{PrunningWorkRepository}
			Modulo físico que almacena el resultado del chequeo de tipos para un conjunto determinado de parametros, una firma de teorema y un arbol de testing en particular.
			Este módulo se empleaba en la primera versión de la poda pero en la versión actual es obsoleto.
			Oculta las estructuras de datos empleadas para cumplir con su funcionalidad.
			\subsection{TheoremSignature}
			Modulo fisico que abstrae la firma de un teorema.
			Oculta los algoritmos y estructuras de datos que emplea para cumplir con su funcionalidad.
			\subsection{TypeCheckingUtils}
			Modulo fisico que brinda funcionalidades generales para los modulos encargados del chequeo de tipos.
			Oculta los algoritmos y estructuras de datos que emplea para cumplir con su funcionalidad.
			\subsection{TypeChecker}
			Modulo fisico que dado un teorema, una clase de prueba y un conjunto de cadenas que representan expresiones de la clase que se pasarán como parámetros al teorema, se encarga de parsear las cadenas y realizar un chequeo de tipos sobre la firma del teorema.
			Oculta los algoritmos y estructuras de datos que emplea para cumplir con su funcionalidad.
		\subsection{Rewriting}
		Módulo lógico que agrupa a aquellos módulos encargados de reescribir los predicados de los teoremas de eliminación de una manera alternativa.
			\subsection{RWRules}
			Módulo lógico que contiene a los módulos físicos que abstraen reglas de reescritura de predicados (basándose en conmutatividad de operadores, asociatividad, equivalencia de predicados, etc.), al módulo de carga del archivo de configuración de reglas de reescritura y al módulo que los almacena.
				\subsection{RWEquality}
				Módulo físico que se encarga de aplicar la propiedad de conmutatividad del operador de igualdad, devolviendo la expresión original y la que se obtiene de alterar el orden de los operandos.
				\subsection{RWIntersection}
				Módulo físico que se encarga de aplicar la propiedad de conmutatividad del operador de intersección, devolviendo la expresión original y la que se obtiene de alterar el orden de los operandos.
				\subsection{RWUnion}
				Módulo físico que se encarga de aplicar la propiedad de conmutatividad del operador de unión, devolviendo la expresión original y la que se obtiene de alterar el orden de los operandos.
				\subsection{RWNotEqual}
				Módulo físico que se encarga de aplicar la propiedad de conmutatividad del operador de desigualdad, devolviendo la expresión original y la que se obtiene de alterar el orden de los operandos.
				\subsection{RWGreaterThan}
				Módulo físico que se encarga de aplicar la propiedad de conmutatividad del operador de desigualdad, devolviendo la expresión original y la que se obtiene de alterar el orden de los operandos.
				\subsection{RWLessThan}
				Módulo físico que se encarga de aplicar la propiedad de conmutatividad del operador de desigualdad, devolviendo la expresión original y la que se obtiene de alterar el orden de los operandos.
				\subsection{RWGreaterThanEqual}
				Módulo físico que se encarga de aplicar la propiedad de conmutatividad del operador de desigualdad, devolviendo la expresión original y la que se obtiene de alterar el orden de los operandos.
				\subsection{RWLessThanEqual}
				Módulo físico que se encarga de aplicar la propiedad de conmutatividad del operador de desigualdad, devolviendo la expresión original y la que se obtiene de alterar el orden de los operandos.
				\subsection{RWRule}
				Interfaz de la cual heredan todas las reglas de reescritura.
				\subsection{RWRuleOperator}
				Interfaz de la cual heredan todas las reglas de reescritura relacionadas con propiedades de operadores, tales como conmutatividad y asociatividad. Extiende la interfaz RWRule.
				\subsection{RWRuleLaw}
				Interfaz de la cual heredan todas las reglas de reescritura relacionadas con leyes matemáticas. Extiende la interfaz RWRule.
				\subsection{RWRuleLawImpl}
				Módulo físico que implementa la interfaz RWRuleLaw. Los 2 métodos más importantes son match() y rewrite(). El método match() se emplea para determinar si un predicado satisface la ley y el método rewrite() devuelve la expresión alternativa.
				Oculta los algoritmos y estructuras de datos empleados.
				\subsection{RWRulesLoader}
				Módulo físico que se encarga de parsear el archivo de configuración que contiene la definición de las reglas de reescritura, creando instancias de RWRule y cargándolas en la única instancia de RWRulesControl. El módulo oculta los algoritmos que implementan tales tareas.
				\subsection{RWRulesControl}
				Módulo físico que almacena instancias de RWRule. Debe existir una única instancia por lo cual se emplea el patrón de diseño Singleton. El módulo oculta las estructuras de datos que emplea.
		\subsection{Operators}
		Módulo lógico que agrupa a los operadores que implementan los operadores de Fastest, así como también otros módulos afines.
			\subsection{AnythingOperator}
			Módulo físico que implementa el operador anything de Fastest. El operador se emplea para poder representar en un predicado en formato de texto una cadena que puede estar conformada por cualquier caracter.
			Recibe una clase y un predicado en forma de texto y devuelve un valor booleano que determina si en el predicado de la clase se encuentra una linea que satisface la expresion una expresión regular que se crea a partir del predicado.
			Oculta los algoritmos empleados para satisfacer su funcionalidad.
			\subsection{EvalOperator}
			Módulo físico que implementa el operador eval de Fastest. El operador se emplea para evaluar el valor de verdad de un predicado que solo contiene constantes numéricas.
			Oculta los algoritmos empleados para satisfacer su funcionalidad.
			\subsection{SomewhereOperator}
			Módulo físico que implementa el operador somewhere de Fastest. El operado se emplea para determinar si en un determinado ámbito se encuentra una cadena de caracters.
			Oculta los algoritmos empleados para satisfacer su funcionalidad.
			\subsection{OperatorAnalizer}
			Módulo físico que se encarga de coordinar los operadores de Fastest. Analiza qué operador está involucrado en un predicado determinado y llama al operador en cuestión.
			Oculta los algoritmos que emplea.
			\subsection{SpecialLine}
			Módulo físico que almacena información acerca de un predicado atómico que contiene un operador propio de Fastest. Almacena el nombre del teorema al que pertenece, el predicado en cuestión y el operador involucrado.
			Oculta las estructuras de datos empleadas.
	\section{ServerAbstraction}
		Módulo lógico que agrupa los módulos encargados de la abstracción de casos de prueba.
		\subsection{AbstractionLaw}
		Módulo físico que almacena toda la información relacionada a una ley de abstracción. Oculta las estructuras de datos empleadas.
		\subsection{AbstractionRule}
		Módulo físico que almacena toda la información relacionada a una reglar de abstracción. Oculta las estructuras de datos empleadas.
		\subsection{AbstractionUtils}
		Módulo físico que contiene funcionalidades comunes a todo el proceso de abstracción. Oculta los algoritmos y estructuras de datos empleados.
		\subsection{VarComposition}
		Almacena la información que se utiliza en los casos en los que se abstraen más de una variable de la implementación a una variable de la especificación. Oculta las estructuras de datos empleadas.
		\subsection{Parser}
		Módulo lógico que agrupa a los módulos que se encargan de parsear las leyes de abstracción.
			\subsection{TRALLexer}
			Módulo físico generado a partir de la herramienta ANTLR que se encarga del análisis lexicográfico del archivo TRAL. Se modifica recompilando el archivo TRAL.g. Oculta los algoritmos y las estructuras de datos empleadas para cumplir con su objetivo.
			\subsection{TRALParser}
			Módulo físico generado a partir de la herramienta ANTLR que se encarga del parseo propiamente dicho del archivo TRAL. Se modifica recompilando el archivo TRAL.g. Oculta los algoritmos y las estructuras de datos empleadas para cumplir con su objetivo.
		\subsection{ABstractTCaseGeneration}
		Módulo lógico que agrupa a los módulos que se encargan de la abstracción del caso concreto.
			\subsection{ASTAbstraction}
			Módulo físico que se encarga de obtener una caso abstracto a partir de un caso concreto, una ley de abstracción y una lista con los valores capturados para las variables monitoreadas. Interactúa con el módulo VarAbstraction. Oculta los algoritmos empleados para cumplir con su objetivo.
			\subsection{VarAbstraction}
			Módulo físico que se encarga de la abstracción de una regla de abstracción en particular utilizando una lista con los valores capturados de la implementación que fueron monitoreados. Oculta los algoritmos empleados para tal fin.
		\subsection{Types}
		Módulo lógico que agrupa a los módulos que abstraen las variables  con sus correspondientes tipos.
			\subsection{ImplTypes}
			Módulo lógico que agrupa a los módulos que abstraen las variables de la implementación con su información de tipos.
				\subsection{ImplNode}
				Interfaz de la cual heredarán los módulos que almacenan información de tipo de las variables de la implementación. Cualquier nuevo tipo de la implementación soportado debe agregarse como heredero de este módulo.
				\subsection{ImplNodeDB}
				Módulo físico que almacena toda la información de tipos de una variable de la implementación que se implementa como una base de datos. Oculta las estructuras de datos empleadas.
				\subsection{ImplNodeFile}
				Módulo físico que almacena toda la información de tipos de una variable de la implementación que se implementa como un archivo. Oculta las estructuras de datos empleadas.
				\subsection{ImplNodePLType}
				Módulo físico que almacena toda la información de tipos de una variable de la implementación que se implementa como un tipo primitivo del lenguaje. Oculta las estructuras de datos empleadas.
				\subsection{ImplNodePointer}
				Módulo físico que almacena toda la información de tipos de una variable de la implementación que se implementa como un puntero en C. Oculta las estructuras de datos empleadas.
				\subsection{ImplNodeScreen}
				Módulo físico que almacena toda la información necesaria para capturar información de la salida estándar. Oculta las estructuras de datos empleadas.
				\subsection{ImplNodeStructure}
				Módulo físico que almacena toda la información de tipos de una variable de la implementación que se implementa como una estructura. En C asumimos que es un variable de tipo struct y en Java asumimos que es una clase. Oculta las estructuras de datos empleadas.
				\subsection{ImplNodeList}
				Módulo físico que almacena toda la información de tipos de una variable de la implementación que se implementa como una lista. Oculta las estructuras de datos empleadas.
				\subsection{ImplNodeEnumeration}
				Módulo físico que se utiliza para mapear elementos de un tipo primitivo del lenguaje de implementación a elementos de un tipo enumerado en la especificación.
				\subsection{ImplNodeDBColumn}
				Módulo físico que almacena la información de tipos de una columna en una base de datos. Oculta las estructuras de datos empleadas.
				\subsection{ImplNodeField}
				Módulo físico que almacena la información de tipos de un campo de una estructura. Oculta las estructuras de datos empleadas.
			\subsection{SpecTypes}
			Módulo lógico que agrupa a los módulos que abstraen las variables de la especificación con su información de tipos.
				\subsection{SpecNode}
				Interfaz de la cual heredarán los módulos que almacenan información de tipo de las variables de la especificación. Cualquier nuevo tipo de la especificación soportado debe agregarse como heredero de este módulo.
				\subsection{SpecNodeBasicType}
				Módulo físico que almacena toda la información de tipos de una variable de la especificación de tipo básico. Oculta las estructuras de datos empleadas.
				\subsection{SpecNodeFreeType}
				Módulo físico que almacena toda la información de tipos de una variable de la especificación de tipo libre. Oculta las estructuras de datos empleadas.
				\subsection{SpecNodeNat}
				Módulo físico que almacena toda la información de tipos de una variable de la especificación de tipo natural. Oculta las estructuras de datos empleadas.
				\subsection{SpecNodeInt}
				Módulo físico que almacena toda la información de tipos de una variable de la especificación de tipo entero. Oculta las estructuras de datos empleadas.
				\subsection{SpecNodeBinRelation}
				Interfaz de la cual heredarán los módulos que almacenen información de tipos de una relación binaria.
				\subsection{SpecNodeFun}
				Módulo físico que almacena toda la información de tipos de una variable de la especificación que es una función total. Oculta las estructuras de datos empleadas.
				\subsection{SpecNodePFun}
				Módulo físico que almacena toda la información de tipos de una variable de la especificación que es una función parcial. Oculta las estructuras de datos empleadas.
				\subsection{SpecNodeRel}
				Módulo físico que almacena toda la información de tipos de una variable de la especificación que es una relación. Oculta las estructuras de datos empleadas.
				\subsection{SpecNodeSeq}
				Módulo físico que almacena toda la información de tipos de una variable de la especificación que es una secuencia. Oculta las estructuras de datos empleadas.
				\subsection{SpecNodeCartesianProd}
				Módulo físico que almacena toda la información de tipos de una variable de la especificación que es un producto cartesiano. Oculta las estructuras de datos empleadas.
				\subsection{SpecNodeFun}
				Módulo físico que almacena toda la información de tipos de una variable de la especificación que es un conjunto de partes. Oculta las estructuras de datos empleadas.
		\subsection{Capture}
		Módulo físico que agrupa a los módulos involucrados en el proceso de captura de las variables de la implementación.
			\subsection{CapturedVar}
			Interfaz de la cual heredarán los módulos que almacenen el valor de una variable de la implementación.
			\subsection{CapturedVarChar}
			Módulo físico que almacena el valor de una variable que se implementa como un caracter. Oculta las estructuras de datos empleadas.
			\subsection{CapturedVarDB}
			Módulo físico que almacena el valor de una variable que se implementa como una base de datos. Oculta las estructuras de datos empleadas.
			\subsection{CapturedVarFile}
			Módulo físico que almacena el valor de una variable que se implementa como un archivo. Oculta las estructuras de datos empleadas.
			\subsection{CapturedVarInt}
			Módulo físico que almacena el valor de una variable que se implementa como un entero. Oculta las estructuras de datos empleadas.
			\subsection{CapturedVarArray}
			Módulo físico que almacena el valor de una variable que se implementa como un arreglo. Oculta las estructuras de datos empleadas.
			\subsection{CapturedVarList}
			Módulo físico que almacena el valor de una variable que se implementa como una lista. Oculta las estructuras de datos empleadas.
			\subsection{CapturedVarPointer}
			Módulo físico que almacena el valor de una variable que se implementa como un puntero en C. Oculta las estructuras de datos empleadas.
			\subsection{CapturedVarReal}
			Módulo físico que almacena el valor de una variable que se implementa como un real. Oculta las estructuras de datos empleadas.
			\subsection{CapturedVarString}
			Módulo físico que almacena el valor de una variable que se implementa como un string. Oculta las estructuras de datos empleadas.
			\subsection{CapturedVarStructure}
			Módulo físico que almacena el valor de una variable que se implementa como una estructura. Oculta las estructuras de datos empleadas.
			\subsection{CapturedVarScreen}
			Módulo físico que almacena la información necesaria de una variable que debe ser capturada en la salida estándar.
			\subsection{XMLParser}
			Módulo físico que se encarga de parsear los archivos XML que generaron los casos concretos a los que se les agregó código de captura. Toma como parámetro el path del archivo y devuelde una lista con instancias de objetos herederos de CapturedVar que contienen los valores de las variable monitoreadas.
			Oculta los algoritmos y estructuras de datos empleadas.
%% EMPIEZA DesignPatterns





\chapter{DesignPatterns}
Módulo lógico que agrupa a todos los patrones de diseño utilizados en el sistema.
	\section{AndOrPredDistributorVisPatt}
	Patrón de diseño basado en el patrón Visitor.
	\section{AndPredClausesExtractorVisPatt}
	Patrón de diseño basado en el patrón Visitor.
	\section{AndPredClausesRemoverVisPatt}
	Patrón de diseño basado en el patrón Visitor.
	\section{AndPredSimplifierVisPatt}
	Patrón de diseño basado en el patrón Visitor.
	\section{ContainsTermVerifierVisPatt}
	Patrón de diseño basado en el patrón Visitor.
	\section{CServersControlSinglPatt}
	Patrón de diseño basado en el patrón Singleton.
	\section{CZTClonerVisPatt}
	Patrón de diseño basado en el patrón Visitor.
	\section{CZTReplacerVisPatt}
	Patrón de diseño basado en el patrón Visitor.
	\section{DServerConfigSinglPatt}
	Patrón de diseño basado en el patrón Singleton.
	\section{EventAdminCommandPatt}
	Patrón de diseño basado en el patrón Command.
	\section{EventAdminSinglPatt}
	Patrón de diseño basado en el patrón Singleton.
	\section{FiniteModelCreatorVisPatt}
	Patrón de diseño basado en el patrón Visitor.
	\section{ImpliesPredRemover}
	Patrón de diseño basado en el patrón Visitor.
	\section{IteratorPatt}
	Patrón de diseño basado en el patrón Iterator.
	\section{NegPredDistributorVisPatt}
	Patrón de diseño basado en el patrón Visitor.
	\section{OrPredRemoverVisPatt}
	Patrón de diseño basado en el patrón Visitor.
	\section{ParamExtractorVisPatt}
	Patrón de diseño basado en el patrón Visitor.
	\section{PredInOrVerifierVisPatt}
	Patrón de diseño basado en el patrón Visitor.
	\section{PredRemoverVisPatt}
	Patrón de diseño basado en el patrón Visitor.	
	\section{PrimeVarsMakerVisPatt}
	Patrón de diseño basado en el patrón Visitor.
	\section{StringToNumReplacerVisPatt}
	Patrón de diseño basado en el patrón Visitor.
	\section{TacticManagerSinglPatt}
	Patrón de diseño basado en el patrón Singleton.
	\section{TCaseStrategyPatt}
	Patrón de diseño basado en el patrón Strategy.
	\section{TTreeCompositePatt}
	Patrón de diseño basado en el patrón Composite.
	\section{TTreeStrategyPatt}
	Patrón de diseño basado en el patrón Strategy.
	\section{TTreeVisPatt}
	Patrón de diseño basado en el patrón Visitor y que se aplica para aplicar distintas operaciones a los árboles de prueba.
	\section{TypeFMsGenVisPatt}
	Patrón de diseño basado en el patrón Visitor.
	\section{WordsFinderVisPatt}
	Patrón de diseño basado en el patrón Visitor.

\end{document}

